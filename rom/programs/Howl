local e={}local t,a,o=require,{},{startup=e}
local function i(n)local s=o[n]
if s~=nil then if s==e then
error("loop or previous error loading module '"..n..
"'",2)end;return s end;o[n]=e;local h=a[n]if h then s=h()elseif t then s=t(n)else
error("cannot load '"..n.."'",2)end;if s==nil then s=true end;o[n]=s;return s end
a["howl.modules.gist"]=function(...)local n=i"howl.lib.assert"local s=i"howl.class.mixin"
local h=i"howl.lib.settings"local r=i"howl.lib.json"local d=i"howl.platform"local l=d.http;local u=i"howl.lib.Buffer"
local c=i"howl.tasks.Task"local m=i"howl.tasks.Runner"local f=i"howl.files.CopySource"
local w=c:subclass("howl.modules.gist.GistTask"):include(s.filterable):include(s.delegate("sources",{"from","include","exclude"})):addOptions{"gist","summary"}
function w:initialize(v,b,g)c.initialize(self,b,g)self.root=v.root;self.sources=f()
self:exclude{".git",".svn",".gitignore"}self:Description"Uploads files to a gist"end;function w:configure(v)self:_configureOptions(v)
self.sources:configure(v)end
function w:setup(v,b)c.setup(self,v,b)if not
self.options.gist then
v.logger:error("Task '%s': No gist ID specified",self.name)end
if not h.githubKey then
v.logger:error("Task '%s': No GitHub API key specified. Goto https://github.com/settings/tokens/new to create one.",self.name)end end
function w:RunAction(v)local b=self.sources:gatherFiles(self.root)
local g=self.options.gist;local k=h.githubKey;local q={}
for A,O in pairs(b)do
v.logger:verbose("Including "..O.relative)q[O.name]={content=O.contents}end
local j="https://api.github.com/gists/"..g.."?access_token="..k
local x={Accept="application/vnd.github.v3+json",["X-HTTP-Method-Override"]="PATCH"}
local z=r.encodePretty({files=q,description=self.options.summary})local _,E,T=l.request(j,z,x)if not _ then
if E then printError(E.readAll())end;error(result,0)end end;local y={}
function y:gist(v,b)return self:InjectTask(w(self.env,v,b))end;local function p()m:include(y)end;return
{name="gist",description="Uploads files to a gist.",apply=p,GistTask=w}end
a["howl.modules.require"]=function(...)local n=i"howl.lib.assert"
local s=i"howl.platform".fs;local h=i"howl.class.mixin"local r=i"howl.lib.Buffer"local d=i"howl.tasks.Task"
local l=i"howl.tasks.Runner"local u=i"howl.files.CopySource"local c=i"howl.modules.require.header"
local m="local env = setmetatable({ require = require }, { __index = getfenv() })\n"local function f(b)
if b:find("%.lua$")then return
b:gsub("%.lua$",""):gsub("/","."):gsub("^(.*)%.init$","%1")end end
local function w(b)if
b.relative:find("%.res%.")then b.name=b.name:gsub("%.res%.",".")return
("return %q"):format(b.contents)end end
local y=d:subclass("howl.modules.require.RequireTask"):include(h.filterable):include(h.delegate("sources",{"from","include","exclude"})):addOptions{"link","startup","output","api"}
function y:initialize(b,g,k)d.initialize(self,g,k)self.root=b.root;self.sources=u()self.sources:rename(function(q)return
f(q.name)end)
self.sources:modify(w)
self:exclude{".git",".svn",".gitignore",b.out}end;function y:configure(b)d.configure(self,b)
self.sources:configure(b)end
function y:output(b)
n.argType(b,"string","output",1)if self.options.output then
error("Cannot set output multiple times")end;self.options.output=b
self:Produces(b)end
function y:setup(b,g)d.setup(self,b,g)if not self.options.startup then
b.logger:error("Task '%s': No startup file",self.name)end
self:requires(self.options.startup)if not self.options.output then
b.logger:error("Task '%s': No output file",self.name)end end
function y:RunAction(b)local g=self.sources:gatherFiles(self.root)
local k=self.options.startup;local q=self.options.output;local j=self.options.link;local x=r()
x:append(c):append("\n")if j then x:append(m)end
for z,_ in pairs(g)do
b.logger:verbose("Including ".._.relative)
x:append("preload[\"".._.name.."\"] = ")
if j then
n(s.exists(_.path),"Cannot find ".._.relative)
x:append("setfenv(assert(loadfile(\"".._.path.."\")), env)\n")else
x:append("function(...)\n".._.contents.."\nend\n")end end
if self.options.api then x:append("if shell then\n")end
x:append("return preload[\""..f(k).."\"](...)\n")
if self.options.api then x:append("else\n")
x:append("return { require = require, preload = preload }\n")x:append("end\n")end;s.write(s.combine(b.root,q),x:toString())end;local p={}
function p:asRequire(b,g)return
self:InjectTask(y(self.env,b,g)):Description("Packages files together to allow require")end;local function v()l:include(p)end;return
{name="require",description="Combines files that can be loaded using `require`.",apply=v,RequireTask=y}end
a["howl.modules.require.header"]=function(...)
return
"local loading = {}\
local oldRequire, preload, loaded = require, {}, { startup = loading }\
\
local function require(name)\
	local result = loaded[name]\
\
	if result ~= nil then\
		if result == loading then\
			error(\"loop or previous error loading module '\" .. name .. \"'\", 2)\
		end\
\
		return result\
	end\
\
	loaded[name] = loading\
	local contents = preload[name]\
	if contents then\
		result = contents()\
	elseif oldRequire then\
		result = oldRequire(name)\
	else\
		error(\"cannot load '\" .. name .. \"'\", 2)\
	end\
\
	if result == nil then result = true end\
	loaded[name] = result\
	return result\
end\
"end
a["howl.modules.minify"]=function(...)local n=i"howl.lexer.rebuild"local s=i"howl.tasks.Runner"
local h=i"howl.lib.mediator"local r=n.MinifyFile
local d=function(m,f,w,y)return r(f.root,w,y)end;local l={}
function l:minify(m,f,w,y)
return
self:AddTask(m,y,function(p,v)
if type(f)=="table"then
assert(type(w)=="table","Output File must be a table too")local b=#f
assert(b==#w,"Tables must be the same length")for g=1,b do r(v.root,f[g],w[g])end else r(v.root,f,w)end end):Description(
"Minifies '"..
fs.getName(f).."' into '"..fs.getName(w).."'"):Requires(f):Produces(w)end
function l:addMinifier(m,f,w)m=m or"_minify"return
self:AddTask(m,{},d):Description("Minifies files"):Maps(
f or"wild:*.lua",w or"wild:*.min.lua")end;l.Minify=l.minify;l.RequireAll=l.addMinifier
local function u()s:include(l)end;local function c(m)
m.mediator:subscribe({"HowlFile","env"},function(f)f.Minify=r end)end;return
{name="minify",description="Minifies files, reducing file size.",apply=u,setup=c}end
a["howl.modules.clean"]=function(...)local n=i"howl.class.mixin"
local s=i"howl.platform".fs;local h=i"howl.tasks.Task"local r=i"howl.tasks.Runner"local d=i"howl.files.Source"
local l=h:subclass("howl.modules.clean.CleanTask"):include(n.configurable):include(n.filterable):include(n.delegate("sources",{"from","include","exclude"}))
function l:initialize(c,m,f)h.initialize(self,m,f)self.root=c.root;self.sources=d()
self:exclude{".git",".svn",".gitignore"}self:Description"Deletes all files matching a pattern"end
function l:configure(c)self.sources:configure(c)end;function l:setup(c,m)h.setup(self,c,m)local f=self.sources
if
f.allowEmpty and#f.includes==0 then f:include(s.combine(c.out,"*"))end end
function l:RunAction(c)for m,f in
ipairs(self.sources:gatherFiles(self.root,true))do s.delete(f.path)end end;local u={}function u:clean(c,m)
return self:InjectTask(l(self.env,c or"clean",m))end;return
{name="clean",description="Deletes all files.",apply=function()r:include(u)end,CleanTask=l}end
a["howl.loader"]=function(...)local n=i"howl.lib.utils"local s=i"howl.tasks.Runner"
local h=i"howl.platform".fs;local r={"Howlfile","Howlfile.lua"}
local function d()local c=h.currentDir()
while true do for m,f in
ipairs(r)do local w=h.combine(c,f)
if h.exists(w)and not h.isDir(w)then return f,c end end
if c=="/"or c==""then break end;c=h.getDir(c)end;return nil,
"Cannot find HowlFile. Looking for '"..table.concat(r,"', '").."'."end
local function l(c)local m=setmetatable(c or{},{__index=getfenv()})function m.loadfile(f)return
setfenv(assert(loadfile(f)),m)end;function m.dofile(f)
return m.loadfile(f)()end;return m end
local function u(c,m)local f=s(c)
c.mediator:subscribe({"ArgParse","changed"},function(y)f.ShowTime=y:Get"time"
f.Traceback=y:Get"trace"end)
local w=l({CurrentDirectory=c.root,Tasks=f,Options=c.arguments,Verbose=c.logger/"verbose",Log=c.logger/"dump",File=function(...)
return h.combine(c.root,...)end})c.mediator:publish({"HowlFile","env"},w,c)
return f,w end;return{FindHowl=d,SetupEnvironment=l,SetupTasks=u,Names=r}end
a["howl.external.busted"]=function(...)local n=i"howl.lib.utils"local s=i"howl.tasks.Runner"local h,r,d,l,u=fs.combine,fs.exists,fs.isDir,loadfile,function()
end;local c=busted
local m={"busted.api.lua","../lib/busted.api.lua","busted.api","../lib/busted.api","busted","../lib/busted"}
local function f(v)u("Busted at "..v)local b=l(v)
if b then
u("Busted loading at "..v)local g=setfenv(b,getfenv())()g=g.api or g;if g.run then u(
"Busted found at "..v)return g end end end
local function w(v)if not r(v)then return end;if not d(v)then return f(v)end;local b
for g,k in ipairs(m)do b=h(v,k)if
r(b)then local q=f(b)if q then return q end end end end
local function y()if c then return c end;local v=w("/")if v then c=v;return c end;for b in
string.gmatch(shell.path(),"[^:]+")do local v=w(b)if v then c=v;return c end end end
local function p(v)return
{cwd=v,output='colorTerminal',seed=os.time(),verbose=true,root='spec',tags={},['exclude-tags']={},pattern='_spec',loaders={'lua'},helper=''}end
function s:Busted(v,b,g)
return
self:AddTask(v,g,function(k,q)local c
if b and b.busted then c=w(b.busted)else c=y()end;if not c then error("Cannot find busted")end
local j=p(q.root)for _,E in pairs(b or{})do j[_]=E end;local x,z=c.run(j,p(q.root))if
x~=0 then u(z)error("Not all tests passed")end end):Description("Runs tests")end end
a["howl.class"]=function(...)
local n={_VERSION='middleclass v4.0.0',_DESCRIPTION='Object Orientation for Lua',_URL='https://github.com/kikito/middleclass',_LICENSE=[[
		MIT LICENSE

		Copyright (c) 2011 Enrique GarcÃ­a Cota

		Permission is hereby granted, free of charge, to any person obtaining a
		copy of this software and associated documentation files (the
		"Software"), to deal in the Software without restriction, including
		without limitation the rights to use, copy, modify, merge, publish,
		distribute, sublicense, and/or sell copies of the Software, and to
		permit persons to whom the Software is furnished to do so, subject to
		the following conditions:

		The above copyright notice and this permission notice shall be included
		in all copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
		IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
		CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
		TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
		SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	]]}
local function s(w,y)
if y==nil then return w.__instanceDict else
return function(f,p)local v=w.__instanceDict[p]
if v~=nil then return v elseif type(y)==
"function"then return(y(f,p))else return y[p]end end end end
local function h(w,y,p)p=y=="__index"and s(w,p)or p
w.__instanceDict[y]=p;for f in pairs(w.subclasses)do
if rawget(f.__declaredMethods,y)==nil then h(f,y,p)end end end
local function r(w,y,p)w.__declaredMethods[y]=p;if p==nil and w.super then
p=w.super.__instanceDict[y]end;h(w,y,p)end;local function d(f)return"class "..f.name end
local function l(f,...)return f:new(...)end
local function u(f,w)local y={}y.__index=y
local p={name=f,super=w,static={},__instanceDict=y,__declaredMethods={},subclasses=setmetatable({},{__mode='k'})}
if w then
setmetatable(p.static,{__index=function(v,b)return rawget(y,b)or w.static[b]end})else
setmetatable(p.static,{__index=function(v,b)return rawget(y,b)end})end
setmetatable(p,{__index=p.static,__tostring=d,__call=l,__newindex=r})return p end
local function c(f,w)
assert(type(w)=='table',"mixin must be a table")
for y,p in pairs(w)do if y~="included"and y~="static"then f[y]=p end end;for y,p in pairs(w.static or{})do f.static[y]=p end;if
type(w.included)=="function"then w:included(f)end;return f end
local m={__tostring=function(f)return"instance of "..tostring(f.class)end,initialize=function(f,...)
end,isInstanceOf=function(f,w)
return type(f)=='table'and type(f.class)=='table'and
type(w)=='table'and
(w==f.class or type(w.isSubclassOf)==
'function'and f.class:isSubclassOf(w))end,static={allocate=function(f)
assert(
type(f)=='table',"Make sure that you are using 'Class:allocate' instead of 'Class.allocate'")return setmetatable({class=f},f.__instanceDict)end,new=function(f,...)
assert(
type(f)=='table',"Make sure that you are using 'Class:new' instead of 'Class.new'")local w=f:allocate()w:initialize(...)return w end,subclass=function(f,w)
assert(
type(f)=='table',"Make sure that you are using 'Class:subclass' instead of 'Class.subclass'")
assert(type(w)=="string","You must provide a name(string) for your class")local y=u(w,f)for p,v in pairs(f.__instanceDict)do h(y,p,v)end;y.initialize=function(p,...)return
f.initialize(p,...)end
f.subclasses[y]=true;f:subclassed(y)return y end,subclassed=function(f,w)
end,isSubclassOf=function(f,w)
return type(w)=='table'and type(f)=='table'and type(f.super)==
'table'and
(f.super==w or

type(f.super.isSubclassOf)=='function'and f.super:isSubclassOf(w))end,include=function(f,...)
assert(
type(f)=='table',"Make sure you that you are using 'Class:include' instead of 'Class.include'")for w,y in ipairs({...})do c(f,y)end;return f end}}return
function(f,w)
assert(type(f)=='string',"A name (string) is needed for the new class")return w and w:subclass(f)or c(u(f),m)end end
a["howl.class.mixin"]=function(...)local n=i"howl.lib.assert"local s=rawset;local h={}
h.sealed={static={subclass=function(r,d)
n(type(r)=='table',"Make sure that you are using 'Class:subclass' instead of 'Class.subclass'")
n(type(d)=="string","You must provide a name(string) for your class")
error("Cannot subclass '"..
tostring(r).."' (attempting to create '"..d.."')",2)end}}
h.curry={curry=function(r,d)
n.type(r,"table","Bad argument #1 to class:curry (expected table, got %s)")
n.type(d,"string","Bad argument #2 to class:curry (expected string, got %s)")local l=r[d]
n.type(l,"function","No such function "..d)return function(...)return l(r,...)end end,__div=function(r,d)return
r:curry(d)end}
h.configurable={configureWith=function(r,d)local l=type(d)if l=="table"then r:configure(d)return r elseif l=="function"then d(r)
return r else
error("Expected table or function, got "..type(d),2)end;return r end,__call=function(r,...)return
r:configureWith(...)end}
h.filterable={__add=function(r,...)return r:include(...)end,__sub=function(r,...)return r:exclude(...)end,with=function(r,...)return
r:configure(...)end}
function h.delegate(r,d)local l={}for u,c in ipairs(d)do
l[c]=function(m,...)local f=m[r]return f[c](f,...)end end;return l end
h.optionGroup={static={addOption=function(r,d)
local l=function(r,u)if u==nil then u=true end;r.options[d]=u;return r end;r[d:gsub("^%l",string.upper)]=l;r[d]=l
if not
rawget(r.static,"options")then local u={}r.static.options=u
local c=r.super and r.super.static.options;if c then setmetatable(u,{__index=c})end end;r.static.options[d]=true;return r end,addOptions=function(r,d)for l=1,
#d do r:addOption(d[l])end;return r end},configure=function(r,d)
n.argType(d,"table","configure",1)
for l,u in pairs(d)do if r.class.options[l]then r[l](r,u)end end end,__newindex=function(r,d,l)if keys[d]then
r[d](r,l)else s(r,d,l)end end}return h end
a["howl.lib.json"]=function(...)
local n={["\n"]="\\n",["\r"]="\\r",["\t"]="\\t",["\b"]="\\b",["\f"]="\\f",["\""]="\\\"",["\\"]="\\\\"}
local function s(l)local u=0
for c,m in pairs(l)do if type(c)~="number"then return false elseif c>u then u=c end end;return u==#l end
local function h(l,u,c,m,f)local w=""
local function y(v)w=w.. ("\t"):rep(c)..v end
local function p(l,v,b,g,k)w=w..v;if u then w=w.."\n"c=c+1 end;for q,j in g(l)do y("")k(q,j)w=w..","if u then
w=w.."\n"end end;if u then c=c-1 end
if
w:sub(-2)==",\n"then w=w:sub(1,-3).."\n"elseif w:sub(-1)==","then w=w:sub(1,-2)end;y(b)end
if type(l)=="table"then
assert(not m[l],"Cannot encode a table holding itself recursively")m[l]=true
if s(l)then
p(l,"[","]",ipairs,function(b,g)w=w..h(g,u,c,m)end)else
p(l,"{","}",pairs,function(b,g)
assert(type(b)=="string","JSON object keys must be strings",2)w=w..h(b,u,c,m)
w=w.. (u and": "or":")..h(g,u,c,m,b)end)end elseif type(l)=="string"then
w='"'..l:gsub("[%c\"\\]",n)..'"'elseif type(l)=="number"or type(l)=="boolean"then w=tostring(l)else
error(
"JSON only supports arrays, objects, numbers, booleans, and strings, got "..type(l).." in "..tostring(f),2)end;return w end;local function r(l)return h(l,false,0,{})end
local function d(l)return h(l,true,0,{})end;return{encode=r,encodePretty=d}end
a["howl.lib.settings"]=function(...)local n={}
if fs.exists(".howl.settings")then
local s=fs.open(".howl.settings","r")local h=s.readAll()s.close()for r,d in
pairs(textutils.unserialize(h))do n[r]=d end end;if settings then
if fs.exists(".settings")then settings.load(".settings")end
for s,h in pairs(n)do n[s]=settings.get("howl."..s,h)end end;return n end
a["howl.lib.Buffer"]=function(...)local n=table.concat
local function s(r,d)local l=r.n+1;r[l]=d;r.n=l;return r end;local function h(r)return n(r)end;return
function()return{n=0,append=s,toString=h}end end
a["howl.lib.argparse"]=function(...)local n=i"howl.lib.colored"
local s={__index=function(d,l)
return function(d,...)local u=d.parser
local c=u[l](u,d.name,...)if c==u then return d end;return c end end}local h={}
function h:Get(d,l)local u=self.options;local c=u[d]if c~=nil then return c end
local m=self.settings[d]
if m then local f=m.aliases;if f then
for w,y in ipairs(f)do c=u[y]if c~=nil then return c end end end;c=m.default;if c~=nil then return c end end;return l end;function h:Ensure(d)local l=self:Get(d)
if l==nil then error(d.." must be set")end;return l end;function h:Default(d,l)
if l==nil then l=true end;self:_SetSetting(d,"default",l)self:_Changed()
return self end
function h:Alias(d,l)
local u=self.settings;local c=u[d]if c then local m=c.aliases
if m==nil then c.aliases={l}else table.insert(m,l)end else u[d]={aliases={l}}end
self:_Changed()return self end
function h:Description(d,l)return self:_SetSetting(d,"description",l)end;function h:TakesValue(d,l)if l==nil then l=true end
return self:_SetSetting(d,"takesValue",l)end
function h:_SetSetting(d,l,u)local c=self.settings
local m=c[d]if m then m[l]=u else c[d]={[l]=u}end;return self end
function h:Option(d)return setmetatable({name=d,parser=self},s)end;function h:Arguments()return self.arguments end;function h:_Changed()
self.mediator:publish({"ArgParse","changed"},self)end
function h:Help(d)
for l,u in pairs(self.settings)do local c='-'if
u.takesValue then c="--"l=l.."=value"end;if#l>1 then c='--'end;n.writeColor("white",d..c..
l)local m=""local f=u.aliases
if f and#f>0 then local y=#f
m=m.." ("for p=1,y do local v="-"..f[p]if#v>2 then v="-"..v end;if p<y then v=v..', 'end
m=m..v end;m=m..")"end;n.writeColor("brown",m)local w=u.description;if w and w~=""then
n.printColor("lightGray"," "..w)end end end
function h:Parse(d)local l=self.options;local u=self.arguments
for c,m in ipairs(d)do
if m:sub(1,1)=="-"then
if
m:sub(2,2)=="-"then local f,w=m:match("([%w_%-]+)=([%w_%-]+)",3)if f then l[f]=w else
m=m:sub(3)local y=m:sub(1,4)local w=true
if y=="not-"or y=="not_"then w=false;m=m:sub(5)end;l[m]=w end else for f=2,#m do
l[m:sub(f,f)]=true end end else table.insert(u,m)end end;return self end
local function r(d,l)return
setmetatable({options={},arguments={},mediator=d,settings={}},{__index=h}):Parse(l)end;return{Parser=h,Options=r}end
a["howl.lib.mediator"]=function(...)local n=i"howl.class"local s=i"howl.class.mixin"local function h()return
tonumber(tostring({}):match(':%s*[0xX]*(%x+)'),16)end
local r=n("howl.lib.mediator.Subscriber"):include(s.sealed)
function r:initialize(u,c)self.id=h()self.options=c or{}self.fn=u end;function r:update(u)self.fn=u.fn or self.fn
self.options=u.options or self.options end
local d=n("howl.lib.mediator.Channel"):include(s.sealed)function d:initialize(u,c)self.stopped=false;self.namespace=u;self.callbacks={}
self.channels={}self.parent=c end
function d:addSubscriber(u,c)
local m=r(u,c)local f=(#self.callbacks+1)c=c or{}
if c.priority and
c.priority>=0 and c.priority<f then f=c.priority end;table.insert(self.callbacks,f,m)return m end
function d:getSubscriber(u)for m=1,#self.callbacks do local f=self.callbacks[m]if f.id==u then
return{index=m,value=f}end end;local c
for m,f in
pairs(self.channels)do c=f:getSubscriber(u)if c then break end end;return c end
function d:setPriority(u,c)local m=self:getSubscriber(u)
if m.value then
table.remove(self.callbacks,m.index)table.insert(self.callbacks,c,m.value)end end
function d:addChannel(u)self.channels[u]=d(u,self)return self.channels[u]end
function d:hasChannel(u)return u and self.channels[u]and true end;function d:getChannel(u)
return self.channels[u]or self:addChannel(u)end
function d:removeSubscriber(u)
local c=self:getSubscriber(u)
if c and c.value then
for m,f in pairs(self.channels)do f:removeSubscriber(u)end;return table.remove(self.callbacks,c.index)end end
function d:publish(u,...)
for c=1,#self.callbacks do local m=self.callbacks[c]
if
not m.options.predicate or m.options.predicate(...)then local f,w=m.fn(...)if
w~=nil then table.insert(u,w)end
if f==false then return false,u end end end
if parent then return parent:publish(u,...)else return true,u end end
local l=setmetatable({Channel=d,Subscriber=r},{__call=function(u,c)
return
{channel=d('root'),getChannel=function(m,f)local w=m.channel
for y=1,#f do w=w:getChannel(f[y])end;return w end,subscribe=function(m,f,u,c)return
m:getChannel(f):addSubscriber(u,c)end,getSubscriber=function(m,f,w)return
m:getChannel(w):getSubscriber(f)end,removeSubscriber=function(m,f,w)return
m:getChannel(w):removeSubscriber(f)end,publish=function(m,f,...)return
m:getChannel(f):publish({},...)end}end})return l()end
a["howl.lib.colored"]=function(...)local n=i"howl.platform".term;local function s(r,...)n.setColor(r)
print(...)n.resetColor(r)end;local function h(r,d)n.setColor(r)
io.write(d)n.resetColor(r)end
return{printColor=s,writeColor=h}end
a["howl.lib.utils"]=function(...)
local n={["^"]="%^",["$"]="%$",["("]="%(",[")"]="%)",["%"]="%%",["."]="%.",["["]="%[",["]"]="%]",["*"]="%*",["+"]="%+",["-"]="%-",["?"]="%?",["\0"]="%z"}local function s(c)return(c:gsub(".",n))end
local h={["^"]="%^",["$"]="%$",["("]="%(",[")"]="%)",["%"]="%%",["."]="%.",["["]="%[",["]"]="%]",["+"]="%+",["-"]="%-",["?"]="%?",["\0"]="%z"}
local function r(c,m)local f=c:sub(1,5)
if f=="ptrn:"or f=="wild:"then local c=c:sub(6)
if f=="wild:"then
if m then
local w=0
c=((c:gsub(".",h)):gsub("(%*)",function()w=w+1;return"%"..w end))else c="^"..
((c:gsub(".",h)):gsub("(%*)","(.*)")).."$"end end;return{Type="Pattern",Text=c}else return{Type="Normal",Text=c}end end;local function d(c)for m,f in ipairs(c)do c[f]=true end;return c end;local function l(c,m)
local f=#c;if f~=#m then return false end
for w=1,f do if c[w]~=m[w]then return false end end;return true end;local function u(c,m)
if c:sub(1,
#m)==m then return c:sub(#m+1)else return false end end;return
{escapePattern=s,parsePattern=r,createLookup=d,matchTables=l,startsWith=u}end
a["howl.lib.dump"]=function(...)local n=i("howl.lib.Buffer")
local s=i("howl.lib.utils").createLookup;local h,r,d=type,tostring,string.format;local l,u=getmetatable,error
local function c(p,v,b)local g=h(p)
if
g=="table"and not v[p]then v[p]=true
if next(p)==nil then return"{}"else local k=false;local q=#p;local j=0
for I,N in
pairs(p)do
if h(I)=="table"or h(N)=="table"then k=true;break elseif
h(I)=="number"and I>=1 and I<=q and I%1 ==0 then j=j+#r(N)+2 else j=
j+#r(N)+#r(I)+2 end;if j>40 then k=true;break end end;local x,z,_="",", "," "if k then x="\n"z=",\n"_=b.." "end;local E,T={
(tupleLength and"("or"{")..x},1;local A={}local O=true
for I=1,q do
A[I]=true;T=T+1;local N=_..c(p[I],v,_)if not O then N=z..N else O=false end;E[T]=N end
for I,N in pairs(p)do
if not A[I]then local S;if
h(I)=="string"and string.match(I,"^[%a_][%a%d_]*$")then S=I.." = "..c(N,v,_)else
S="["..c(I,v,_).."] = "..c(N,v,_)end;S=_..S;if not O then
S=z..S else O=false end;T=T+1;E[T]=S end end;T=T+1
E[T]=x..b.. (tupleLength and")"or"}")return table.concat(E)end elseif g=="string"then return
(string.format("%q",p):gsub("\\\n","\\n"))else return r(p)end end;local function m(p,v)return c(p,{},"")end
local f=s{"and","break","do","else","elseif","end","false","for","function","if","in","local","nil","not","or","repeat","return","then","true","until","while"}
local function w(p,v,b)local g=h(p)
if g=="table"then if v[p]then
u("Cannot serialise table with recursive entries",1)end;v[p]=true
if next(p)==nil then
b:append("{}")else b:append("{")local k={}
for q,j in ipairs(p)do k[q]=true;w(j,v,b)b:append(",")end
for q,j in pairs(p)do
if not k[q]then
if
h(q)=="string"and not f[q]and q:match("^[%a_][%a%d_]*$")then b:append(q.."=")else b:append("[")w(q,v,b)b:append("]=")end;w(j,v,b)b:append(",")end end;b:append("}")end elseif g=="string"then b:append(d("%q",p))elseif g=="number"or g=="boolean"or
g=="nil"then b:append(r(p))else
u("Cannot serialise type "..g)end;return b end;local function y(p)return w(p,{},n()):toString()end;return
{serialise=y,dump=m}end
a["howl.lib.assert"]=function(...)local n,s,h,r=type,error,select,math.floor;local d=assert
local l=setmetatable({assert=d},{__call=function(m,...)return
d(...)end})
local function u(n,m,f)if f then return s(f:format(n))else
return s(m.." expected, got "..n)end end
function l.type(m,f,w)local y=n(m)if y~=f then return u(y,f,w)end end
local function c(n,m,f,w)return
s("bad argument #"..w.." for "..
f.." (expected "..m..", got "..n..")")end
function l.argType(m,f,w,y)local p=n(m)if p~=f then return c(p,f,w,y)end end
function l.args(m,...)local f=r('#',...)local w={...}
for y=1,f,2 do local p=n(w[i])local v=w[i+1]if p~=v then return
c(p,v,m,math.floor(y/2))end end end;l.typeError=u;l.argError=c
function l.class(m,f,w)local y=n(m)
if
y~="table"or not m.isInstanceOf then return u(y,f,w)elseif not m:isInstanceOf(f)then return u(m.class.name,f,w)end end;return l end
a["howl.lib.Logger"]=function(...)local n=i"howl.class"local s=i"howl.class.mixin"
local h=i"howl.lib.dump".dump;local r=i"howl.lib.colored"
local d=n("howl.lib.Logger"):include(s.sealed):include(s.curry)function d:initialize(c)self.isVerbose=false
c.mediator:subscribe({"ArgParse","changed"},function(m)self.isVerbose=
m:Get"verbose"or false end)end;function d:verbose(...)
if
self.isVerbose then local c,f=pcall(function()error("",4)end)
r.writeColor("gray",f)r.printColor("lightGray",...)end end
function d:dump(...)
if
self.isVerbose then local c,f=pcall(function()error("",4)end)
r.writeColor("gray",f)local w=select('#',...)local y={...}for m=1,w do local p=y[m]local v=type(p)if v=="table"then p=h(p)else
p=tostring(p)end;if m>1 then p=" "..p end
r.writeColor("lightGray",p)end
print()end end
local l={{"success","ok","green"},{"error","error","red"},{"info","info","cyan"},{"warning","warn","yellow"}}local u=0;for c,m in ipairs(l)do u=math.max(u,#m[2])end
for c,m in ipairs(l)do
local f=m[3]
local w='['..m[2]..']'.. (' '):rep(u-#m[2]+1)
local y="has"..m[2]:gsub("^%l",string.upper)
d[m[1]]=function(p,v,...)p[y]=true;r.writeColor(f,w)if type(v)=="string"then
print(v:format(...))else print(v,...)end end end;return d end
a["howl.platform"]=function(...)if fs and term then return i"howl.platform.cc"else
return i"howl.platform.native"end end
a["howl.platform.cc"]=function(...)local n=term.getTextColor and term.getTextColor()or
colors.white
local function s(w)
local y=fs.open(w,"r")local p=y.readAll()y.close()return p end
local function h(w,y)local p=fs.open(w,"w")p.write(y)p.close()end;local function r(w,y,p)
if not fs.exists(w)then error("Cannot find "..y.." (Looking for "..w..")",
p or 1)end end
local d,l=os.queueEvent,coroutine.yield;local function u()d("sleep")
if l()=="terminate"then error("Terminated")end end
local function c(w)local y=#w+2;local p,v={w},1;local b={}while v>0 do
local g=p[v]v=v-1
if fs.isDir(g)then
for k,q in ipairs(fs.list(g))do v=v+1;p[v]=fs.combine(g,q)end else b[g:sub(y)]=s(g)end end;return b end
local function m(w,y)for p,v in pairs(y)do h(fs.combine(w,p),v)end end;local f
if http.fetch then
f=function(w,y,p)local v,b=http.fetch(w,y,p)
if v then
while true do local g,k,q,j=os.pullEvent(e)if g==
"http_success"and k==w then return true,q elseif g=="http_failure"and k==w then
return false,j,q end end end;return false,nil,b end else
f=function(...)local w,y=http.post(...)
if w then return true,y else return false,nil,y end end end
return
{fs={combine=fs.combine,normalise=function(w)return fs.combine(w,"")end,getDir=fs.getDir,getName=getName,currentDir=shell.dir,read=s,write=h,readDir=c,writeDir=m,assertExists=r,exists=fs.exists,isDir=fs.isDir,list=fs.list,makeDir=fs.makeDir,delete=fs.delete,move=fs.move,copy=fs.copy},term={setColor=function(w)local y=
colours[w]or colors[w]if not y then
error("Unknown color "..w,2)end;term.setTextColor(y)end,resetColor=function()
term.setTextColor(n)end},http={request=f},refreshYield=u}end
a["howl.platform.native"]=function(...)local n=string.char(27)..'['
local s={white=97,orange=33,magenta=95,lightBlue=94,yellow=93,lime=92,pink=95,gray=90,grey=90,lightGray=37,lightGrey=37,cyan=96,purple=35,blue=36,brown=31,green=32,red=91,black=30}local function h(u)return
function()error(u.." is not implemented",2)end end
local r=i('pl.path')local d=i('pl.dir')local l=i('pl.file')
return
{fs={combine=r.join,normalise=r.normpath,getDir=r.dirname,getName=r.basename,currentDir=function()
return r.currentdir end,read=l.read,write=l.write,readDir=h("fs.readDir"),writeDir=h("fs.writeDir"),assertExists=function(l)if not r.exists(l)then
error("File does not exist")end end,exists=r.exists,isDir=r.isdir,list=function(d)
local u={}for r in r.dir(d)do u[#u+1]=r end;return u end,makeDir=d.makepath,delete=function(u)if
r.isdir(u)then d.rmtree(u)else l.delete(u)end end,move=l.move,copy=l.copy},http={request=h("http.request")},term={setColor=function(u)
local c=s[u]if not c then
error("Cannot find color "..tostring(u),2)end;io.write(n..c.."m")
io.flush()end,resetColor=function()
io.write(n.."0m")io.flush()end},refreshYield=function()
end}end
a["howl.lexer.rebuild"]=function(...)local n=i"howl.lexer.constants"local s=i"howl.lexer.parse"
local h=i"howl.platform"local r=n.LowerChars;local d=n.UpperChars;local l=n.Digits;local u=n.Symbols
local function c(y,p,v)v=v or' '
local b,g=y:sub(-1,-1),p:sub(1,1)
if d[b]or r[b]or b=='_'then
if not
(g=='_'or d[g]or r[g]or l[g])then return y..p else return y..v..p end elseif l[b]then
if g=='('then return y..p elseif u[g]then return y..p else return y..v..p end elseif b==''then return y..p else if g=='('then return y..v..p else return y..p end end end
local function m(y)local p,v;local b=0;local function g(q,j,x)
if b>150 then b=0;return q.."\n"..j else return c(q,j,x)end end
v=function(q,j)local j=j or 0;local x=0;local z=false;local _=""
if
q.AstType=='VarExpr'then
if q.Variable then _=_..q.Variable.Name else _=_..q.Name end elseif q.AstType=='NumberExpr'then _=_..q.Value.Data elseif q.AstType=='StringExpr'then _=_..
q.Value.Data elseif q.AstType=='BooleanExpr'then
_=_..tostring(q.Value)elseif q.AstType=='NilExpr'then _=g(_,"nil")elseif q.AstType=='BinopExpr'then
x=q.OperatorPrecedence;_=g(_,v(q.Lhs,x))_=g(_,q.Op)_=g(_,v(q.Rhs))if q.Op=='^'or q.Op==
'..'then x=x-1 end;if x<j then z=false else z=true end elseif
q.AstType=='UnopExpr'then _=g(_,q.Op)_=g(_,v(q.Rhs))elseif q.AstType=='DotsExpr'then _=_..
"..."elseif q.AstType=='CallExpr'then _=_..v(q.Base)_=_.."("for E=1,#q.Arguments do _=
_..v(q.Arguments[E])
if E~=#q.Arguments then _=_..","end end;_=_..")"elseif
q.AstType=='TableCallExpr'then _=_..v(q.Base)_=_..v(q.Arguments[1])elseif q.AstType==
'StringCallExpr'then _=_..v(q.Base)
_=_..q.Arguments[1].Data elseif q.AstType=='IndexExpr'then _=_..
v(q.Base).."["..v(q.Index).."]"elseif q.AstType=='MemberExpr'then _=_..v(q.Base)..q.Indexer..
q.Ident.Data elseif q.AstType==
'Function'then q.Scope:ObfuscateLocals()_=_.."function("
if#
q.Arguments>0 then for E=1,#q.Arguments do _=_..q.Arguments[E].Name
if E~=#
q.Arguments then _=_..","elseif q.VarArg then _=_..",..."end end elseif q.VarArg then
_=_.."..."end;_=_..")"_=g(_,p(q.Body))_=g(_,"end")elseif
q.AstType=='ConstructorExpr'then _=_.."{"
for E=1,#q.EntryList do local T=q.EntryList[E]
if T.Type=='Key'then _=_.."["..v(T.Key).."]="..
v(T.Value)elseif
T.Type=='Value'then _=_..v(T.Value)elseif T.Type=='KeyString'then _=_..T.Key..
"="..v(T.Value)end;if E~=#q.EntryList then _=_..","end end;_=_.."}"elseif q.AstType=='Parentheses'then
_=_.."("..v(q.Inner)..")"end;if not z then
_=string.rep('(',q.ParenCount or 0).._
_=_..string.rep(')',q.ParenCount or 0)end;b=b+#_;return _ end
local k=function(q)local j=''
if q.AstType=='AssignmentStatement'then for x=1,#q.Lhs do j=j..v(q.Lhs[x])if x~=#
q.Lhs then j=j..","end end
if
#q.Rhs>0 then j=j.."="for x=1,#q.Rhs do j=j..v(q.Rhs[x])
if x~=#q.Rhs then j=j..","end end end elseif q.AstType=='CallStatement'then j=v(q.Expression)elseif
q.AstType=='LocalStatement'then j=j.."local "
for x=1,#q.LocalList do
j=j..q.LocalList[x].Name;if x~=#q.LocalList then j=j..","end end;if#q.InitList>0 then j=j.."="
for x=1,#q.InitList do
j=j..v(q.InitList[x])if x~=#q.InitList then j=j..","end end end elseif
q.AstType=='IfStatement'then j=g("if",v(q.Clauses[1].Condition))
j=g(j,"then")j=g(j,p(q.Clauses[1].Body))
for x=2,#q.Clauses do
local z=q.Clauses[x]if z.Condition then j=g(j,"elseif")j=g(j,v(z.Condition))
j=g(j,"then")else j=g(j,"else")end
j=g(j,p(z.Body))end;j=g(j,"end")elseif q.AstType=='WhileStatement'then
j=g("while",v(q.Condition))j=g(j,"do")j=g(j,p(q.Body))j=g(j,"end")elseif
q.AstType=='DoStatement'then j=g(j,"do")j=g(j,p(q.Body))j=g(j,"end")elseif
q.AstType=='ReturnStatement'then j="return"
for x=1,#q.Arguments do j=g(j,v(q.Arguments[x]))if x~=#
q.Arguments then j=j..","end end elseif q.AstType=='BreakStatement'then j="break"elseif q.AstType=='RepeatStatement'then j="repeat"
j=g(j,p(q.Body))j=g(j,"until")j=g(j,v(q.Condition))elseif q.AstType=='Function'then
q.Scope:ObfuscateLocals()if q.IsLocal then j="local"end;j=g(j,"function ")if q.IsLocal then
j=j..q.Name.Name else j=j..v(q.Name)end;j=j.."("
if
#q.Arguments>0 then
for x=1,#q.Arguments do j=j..q.Arguments[x].Name;if
x~=#q.Arguments then j=j..","elseif q.VarArg then j=j..",..."end end elseif q.VarArg then j=j.."..."end;j=j..")"j=g(j,p(q.Body))j=g(j,"end")elseif
q.AstType=='GenericForStatement'then q.Scope:ObfuscateLocals()j="for "for x=1,#q.VariableList do j=j..
q.VariableList[x].Name
if x~=#q.VariableList then j=j..","end end;j=j.." in"
for x=1,#q.Generators do
j=g(j,v(q.Generators[x]))if x~=#q.Generators then j=g(j,',')end end;j=g(j,"do")j=g(j,p(q.Body))j=g(j,"end")elseif
q.AstType=='NumericForStatement'then q.Scope:ObfuscateLocals()j="for "
j=j..q.Variable.Name.."="j=j..v(q.Start)..","..v(q.End)if q.Step then j=j..","..
v(q.Step)end;j=g(j,"do")
j=g(j,p(q.Body))j=g(j,"end")elseif q.AstType=='LabelStatement'then
j="::"..q.Label.."::"elseif q.AstType=='GotoStatement'then j="goto "..q.Label elseif q.AstType=='Comment'then elseif q.AstType==
'Eof'then else
error("Unknown AST Type: "..q.AstType)end;b=b+#j;return j end
p=function(q)local j=''q.Scope:ObfuscateLocals()for x,z in pairs(q.Body)do
j=g(j,k(z),';')end;return j end;return p(y)end;local function f(y)local p=s.LexLua(y)h.refreshYield()local v=s.ParseLua(p)
h.refreshYield()return m(v)end
local function w(y,p,v)v=v or p
local b=fs.open(fs.combine(y,p),"r")local g=b.readAll()b.close()g=f(g)
local k=fs.open(fs.combine(y,v),"w")k.write(g)k.close()end;return{JoinStatements=c,Minify=m,MinifyString=f,MinifyFile=w}end
a["howl.lexer.TokenList"]=function(...)local n=math.min;local s=table.insert
return
function(h)local r=#h;local d=1;local function l(b)return h[n(r,d+
(b or 0))]end;local function u(b)local g=h[d]
d=n(d+1,r)if b then s(b,g)end;return g end;local function c(b)
return l().Type==b end
local function m(b,g)local k=l()
if k.Type=='Symbol'then if b then if k.Data==b then if g then s(g,k)end
d=d+1;return true else return nil end else if g then s(g,k)end;d=d+1
return k end else return nil end end
local function f(b,g)local k=l()if k.Type=='Keyword'and k.Data==b then if g then s(g,k)end;d=d+1
return true else return nil end end
local function w(b)local g=l()return g.Type=='Keyword'and g.Data==b end
local function y(b)local g=l()return g.Type=='Symbol'and g.Data==b end;local function p()return l().Type=='Eof'end
local function v(b)
b=(b==nil and true or b)local g=""
for k,q in ipairs(h)do if b then
for k,j in ipairs(q.LeadingWhite)do g=g..j:Print().."\n"end end;g=g..q:Print().."\n"end;return g end
return{Peek=l,Get=u,Is=c,ConsumeSymbol=m,ConsumeKeyword=f,IsKeyword=w,IsSymbol=y,IsEof=p,Print=v,Tokens=h}end end
a["howl.lexer.constants"]=function(...)
local function n(s)for h,r in ipairs(s)do s[r]=h end;return s end
return
{WhiteChars=n{' ','\n','\t','\r'},EscapeLookup={['\r']='\\r',['\n']='\\n',['\t']='\\t',['"']='\\"',["'"]="\\'"},LowerChars=n{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'},UpperChars=n{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'},Digits=n{'0','1','2','3','4','5','6','7','8','9'},HexDigits=n{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'},Symbols=n{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'},Keywords=n{'and','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while'},StatListCloseKeywords=n{'end','else','elseif','until'},UnOps=n{'-','not','#'}}end
a["howl.lexer.Scope"]=function(...)local n=i"howl.lexer.constants".Keywords;local s={}function s:AddLocal(r,d)
table.insert(self.Locals,d)self.LocalMap[r]=d end
function s:CreateLocal(r)
local d=self:GetLocal(r)if d then return d end
d={Scope=self,Name=r,IsGlobal=false,CanRename=true,References=1}self:AddLocal(r,d)return d end;function s:GetLocal(r)
repeat local d=self.LocalMap[r]if d then return d end;self=self.Parent until not self end;function s:GetOldLocal(r)if
self.oldLocalNamesMap[r]then return self.oldLocalNamesMap[r]end;return
self:GetLocal(r)end
function s:RenameLocal(r,d)r=
type(r)=='string'and r or r.Name
repeat
local l=self.LocalMap[r]
if l then l.Name=d;self.oldLocalNamesMap[r]=l
self.LocalMap[r]=nil;self.LocalMap[d]=l;break end;self=self.Parent until not self end;function s:AddGlobal(r,d)table.insert(self.Globals,d)
self.GlobalMap[r]=d end
function s:CreateGlobal(r)
local d=self:GetGlobal(r)if d then return d end
d={Scope=self,Name=r,IsGlobal=true,CanRename=true,References=1}self:AddGlobal(r,d)return d end
function s:GetGlobal(r)repeat local d=self.GlobalMap[r]if d then return d end;self=self.Parent until
not self end;function s:GetVariable(r)
return self:GetLocal(r)or self:GetGlobal(r)end;function s:GetAllVariables()return
self:getVars(true,self:getVars(true))end
function s:getVars(r,d)
local d=d or{}
if r then for l,u in pairs(self.Children)do u:getVars(true,d)end else for l,u in
pairs(self.Locals)do table.insert(d,u)end;for l,u in pairs(self.Globals)do
table.insert(d,u)end;if self.Parent then
self.Parent:getVars(false,d)end end;return d end
function s:ObfuscateLocals(r)
local d=r or"etaoinshrdlucmfwypvbgkqjxz_ETAOINSHRDLUCMFWYPVBGKQJXZ"
local l=r or"etaoinshrdlucmfwypvbgkqjxz_0123456789ETAOINSHRDLUCMFWYPVBGKQJXZ"local u,c=#d,#l;local m=0;local f=math.floor
for w,y in pairs(self.Locals)do local p
repeat
if m<u then m=m+1
p=d:sub(m,m)else
if m<u then m=m+1;p=d:sub(m,m)else local v=f(m/u)local b=m%u;p=d:sub(b,b)while v>0 do b=v%c;p=
l:sub(b,b)..p;v=f(v/c)end;m=m+1 end end until not(n[p]or self:GetVariable(p))self:RenameLocal(y.Name,p)end end;function s:ToString()return'<Scope>'end
local function h(r)
local d=setmetatable({Parent=r,Locals={},LocalMap={},Globals={},GlobalMap={},oldLocalNamesMap={},Children={}},{__index=s})if r then table.insert(r.Children,d)end;return d end;return h end
a["howl.lexer.parse"]=function(...)local n=i"howl.lexer.constants"local s=i"howl.lexer.Scope"
local h=i"howl.lexer.TokenList"local r=n.LowerChars;local d=n.UpperChars;local l=n.Digits;local u=n.Symbols;local c=n.HexDigits
local m=n.Keywords;local f=n.StatListCloseKeywords;local w=n.UnOps;local y,p=table.insert,setmetatable
local v={}
function v:Print()return
"<".. (self.Type..
string.rep(' ',math.max(3,12-#self.Type))).."  "..
(self.Data or'').." >"end;local b={__index=v}
local function g(q)local j={}
do local z=string.sub;local _=1;local E=1;local T=1
local function A()local R=z(q,_,_)if R=='\n'then
T=1;E=E+1 else T=T+1 end;_=_+1;return R end;local function O(R)R=R or 0;return z(q,_+R,_+R)end
local function I(R)local D=O()for L=1,#R do if
D==R:sub(L,L)then return A()end end end;local function N(R)
error(">> :"..E..":"..T..": "..R,0)end
local function S()local R=_
if O()=='['then local D=0;local L=1
while O(D+1)=='='do D=D+1 end
if O(D+1)=='['then for F=0,D+1 do A()end;local U=_
while true do if O()==''then
N("Expected `]"..string.rep('=',D)..
"]` near <eof>.",3)end;local F=true
if O()==']'then for W=1,D do
if O(W)~='='then F=false end end;if O(D+1)~=']'then F=false end else
if O()=='['then local W=true;for Y=1,D do if
O(Y)~='='then W=false;break end end;if
O(D+1)=='['and W then L=L+1;for Y=1,(D+2)do A()end end end;F=false end
if F then L=L-1;if L==0 then break else for W=1,D+2 do A()end end else A()end end;local C=q:sub(U,_-1)for F=0,D+1 do A()end;local M=q:sub(R,_-1)return C,M else return nil end else return nil end end;local function H(R)return R>='0'and R<='9'end
while true do local R,D
while true do local F=z(q,_,_)
if F==
'#'and O(1)=='!'and E==1 then A()A()leadingWhite="#!"while O()~='\n'and
O()~=''do A()end end
if F==' 'or F=='\t'then T=T+1;_=_+1 elseif F=='\n'or F=='\r'then T=1;E=E+1;_=_+1 elseif F=='-'and
O(1)=='-'then A()A()local W,Y,P=E,T,_;local V,B=S()
if not V then local G=z(q,_,_)while G~='\n'and G~=''do A()
G=z(q,_,_)end;V=z(q,P,_-1)end;if not R then R={}D=0 end;D=D+1;R[D]={Data=V,Line=W,Char=Y}else break end end;local L=E;local U=T;local C=z(q,_,_)local M=nil
if C==''then M={Type='Eof'}elseif

(C>='A'and C<='Z')or(C>='a'and C<='z')or C=='_'then local F=_
repeat A()C=z(q,_,_)until not
(
(C>='A'and C<='Z')or(C>='a'and C<='z')or C=='_'or(C>='0'and C<='9'))local W=q:sub(F,_-1)if m[W]then M={Type='Keyword',Data=W}else
M={Type='Ident',Data=W}end elseif(C>='0'and C<='9')or
(C=='.'and l[O(1)])then local F=_
if C=='0'and O(1)=='x'then A()A()while c[O()]do A()end;if
I('Pp')then I('+-')while l[O()]do A()end end else while l[O()]do A()end;if
I('.')then while l[O()]do A()end end
if I('Ee')then I('+-')if not l[O()]then
N("Expected exponent")end;repeat A()until not l[O()]end;local W=O():lower()if(W>='a'and W<='z')or W=='_'then
N("Invalid number format")end end;M={Type='Number',Data=q:sub(F,_-1)}elseif C=='\''or C=='\"'then
local F=_;local W=A()local Y=_
while true do local C=A()if C=='\\'then A()elseif C==W then break elseif C==''then
N("Unfinished string near <eof>")end end;local P=q:sub(Y,_-2)local V=q:sub(F,_-1)
M={Type='String',Data=V,Constant=P}elseif C=='['then local F,W=S()if W then M={Type='String',Data=W,Constant=F}else A()
M={Type='Symbol',Data='['}end elseif
C=='>'or C=='<'or C=='='then A()
if I('=')then M={Type='Symbol',Data=C..'='}else M={Type='Symbol',Data=C}end elseif C=='~'then A()if I('=')then M={Type='Symbol',Data='~='}else
N("Unexpected symbol `~` in source.",2)end elseif C=='.'then A()if I('.')then if I('.')then
M={Type='Symbol',Data='...'}else M={Type='Symbol',Data='..'}end else
M={Type='Symbol',Data='.'}end elseif C==':'then A()
if
I(':')then M={Type='Symbol',Data='::'}else M={Type='Symbol',Data=':'}end elseif u[C]then A()M={Type='Symbol',Data=C}else local F,W=S()if F then
M={Type='String',Data=W,Constant=F}else
N("Unexpected Symbol `"..C.."` in source.",2)end end;M.Line=L;M.Char=U;if R then M.Comments=R end;j[#j+1]=M
if M.Type=='Eof'then break end end end;local x=h(j)return x end
local function k(q,j)
local function x(H)
local R=q.Peek().Line..":"..q.Peek().Char..": "..H.."\n"local D=q.Peek()R=R..
" got "..D.Type..": "..D.Data.."\n"local L=0
if type(j)=='string'then
for U in
j:gmatch("[^\n]*\n?")do if U:sub(-1,-1)=='\n'then U=U:sub(1,-2)end;L=L+1;if L==
q.Peek().Line then
R=R..""..U:gsub('\t','    ').."\n"for C=1,q.Peek().Char do local M=U:sub(C,C)R=R..' 'end
R=R.."^"break end end end;error(R)end;local z,_,E,T,A
local function O(H,R)local D=s(H)if not q.ConsumeSymbol('(',R)then
x("`(` expected.")end;local L={}local U=false
while
not q.ConsumeSymbol(')',R)do
if q.Is('Ident')then local M=D:CreateLocal(q.Get(R).Data)
L[#L+1]=M
if not q.ConsumeSymbol(',',R)then if q.ConsumeSymbol(')',R)then break else
x("`)` expected.")end end elseif q.ConsumeSymbol('...',R)then U=true;if not q.ConsumeSymbol(')',R)then
x("`...` must be the last argument of a function.")end;break else
x("Argument name or `...` expected")end end;local C=_(D)if not q.ConsumeKeyword('end',R)then
x("`end` expected after function body")end;return
{AstType='Function',Scope=D,Arguments=L,Body=C,VarArg=U,Tokens=R}end
function T(H)local R={}
if q.ConsumeSymbol('(',R)then local D=z(H)if not q.ConsumeSymbol(')',R)then
x("`)` Expected.")end
return{AstType='Parentheses',Inner=D,Tokens=R}elseif q.Is('Ident')then local D=q.Get(R)local L=H:GetLocal(D.Data)
if not L then
L=H:GetGlobal(D.Data)
if not L then L=H:CreateGlobal(D.Data)else L.References=L.References+1 end else L.References=L.References+1 end;return{AstType='VarExpr',Name=D.Data,Variable=L,Tokens=R}else
x("primary expression expected")end end
function A(H,R)local D=T(H)
while true do local L={}
if q.IsSymbol('.')or q.IsSymbol(':')then
local U=q.Get(L).Data
if not q.Is('Ident')then x("<Ident> expected.")end;local C=q.Get(L)
D={AstType='MemberExpr',Base=D,Indexer=U,Ident=C,Tokens=L}elseif not R and q.ConsumeSymbol('[',L)then local U=z(H)if
not q.ConsumeSymbol(']',L)then x("`]` expected.")end
D={AstType='IndexExpr',Base=D,Index=U,Tokens=L}elseif not R and q.ConsumeSymbol('(',L)then local U={}
while
not q.ConsumeSymbol(')',L)do U[#U+1]=z(H)
if not q.ConsumeSymbol(',',L)then if q.ConsumeSymbol(')',L)then break else
x("`)` Expected.")end end end;D={AstType='CallExpr',Base=D,Arguments=U,Tokens=L}elseif
not R and q.Is('String')then
D={AstType='StringCallExpr',Base=D,Arguments={q.Get(L)},Tokens=L}elseif not R and q.IsSymbol('{')then local U=E(H)
D={AstType='TableCallExpr',Base=D,Arguments={U},Tokens=L}else break end end;return D end
function E(H)local R={}local D=q.Peek()local L=D.Type
if L=='Number'then return
{AstType='NumberExpr',Value=q.Get(R),Tokens=R}elseif L=='String'then
return{AstType='StringExpr',Value=q.Get(R),Tokens=R}elseif L=='Keyword'then local U=D.Data
if U=='nil'then q.Get(R)
return{AstType='NilExpr',Tokens=R}elseif U=='false'or U=='true'then return
{AstType='BooleanExpr',Value=(q.Get(R).Data=='true'),Tokens=R}elseif U=='function'then q.Get(R)local C=O(H,R)
C.IsLocal=true;return C end elseif L=='Symbol'then local U=D.Data
if U=='...'then q.Get(R)
return{AstType='DotsExpr',Tokens=R}elseif U=='{'then q.Get(R)local C={}
local M={AstType='ConstructorExpr',EntryList=C,Tokens=R}
while true do
if q.IsSymbol('[',R)then q.Get(R)local F=z(H)if not q.ConsumeSymbol(']',R)then
x("`]` Expected")end;if not q.ConsumeSymbol('=',R)then
x("`=` Expected")end;local W=z(H)
C[#C+1]={Type='Key',Key=F,Value=W}elseif q.Is('Ident')then local F=q.Peek(1)
if F.Type=='Symbol'and F.Data=='='then
local W=q.Get(R)
if not q.ConsumeSymbol('=',R)then x("`=` Expected")end;local Y=z(H)C[#C+1]={Type='KeyString',Key=W.Data,Value=Y}else
local W=z(H)C[#C+1]={Type='Value',Value=W}end elseif q.ConsumeSymbol('}',R)then break else local F=z(H)C[#C+1]={Type='Value',Value=F}end
if q.ConsumeSymbol(';',R)or q.ConsumeSymbol(',',R)then elseif
q.ConsumeSymbol('}',R)then break else x("`}` or table entry Expected")end end;return M end end;return A(H)end;local I=8
local N={['+']={6,6},['-']={6,6},['%']={7,7},['/']={7,7},['*']={7,7},['^']={10,9},['..']={5,4},['==']={3,3},['<']={3,3},['<=']={3,3},['~=']={3,3},['>']={3,3},['>=']={3,3},['and']={2,2},['or']={1,1}}
function z(H,R)R=R or 0;local D
if w[q.Peek().Data]then local L={}local U=q.Get(L).Data;D=z(H,I)
local C={AstType='UnopExpr',Rhs=D,Op=U,OperatorPrecedence=I,Tokens=L}D=C else D=E(H)end
while true do local L=N[q.Peek().Data]
if L and L[1]>R then local U={}
local C=q.Get(U).Data;local M=z(H,L[2])
local F={AstType='BinopExpr',Lhs=D,Op=C,OperatorPrecedence=L[1],Rhs=M,Tokens=U}D=F else break end end;return D end
local function S(H)local R=nil;local D={}local L=q.Peek()
if L.Type=="Keyword"then local U=L.Data
if U=='if'then q.Get(D)
local C={}local M={AstType='IfStatement',Clauses=C}
repeat local F=z(H)
if not
q.ConsumeKeyword('then',D)then x("`then` expected.")end;local W=_(H)C[#C+1]={Condition=F,Body=W}until
not q.ConsumeKeyword('elseif',D)
if q.ConsumeKeyword('else',D)then local F=_(H)C[#C+1]={Body=F}end
if not q.ConsumeKeyword('end',D)then x("`end` expected.")end;M.Tokens=D;R=M elseif U=='while'then q.Get(D)local C=z(H)if
not q.ConsumeKeyword('do',D)then return x("`do` expected.")end;local M=_(H)if not
q.ConsumeKeyword('end',D)then x("`end` expected.")end
R={AstType='WhileStatement',Condition=C,Body=M,Tokens=D}elseif U=='do'then q.Get(D)local C=_(H)if not q.ConsumeKeyword('end',D)then
x("`end` expected.")end
R={AstType='DoStatement',Body=C,Tokens=D}elseif U=='for'then q.Get(D)
if not q.Is('Ident')then x("<ident> expected.")end;local C=q.Get(D)
if q.ConsumeSymbol('=',D)then local M=s(H)
local F=M:CreateLocal(C.Data)local W=z(H)
if not q.ConsumeSymbol(',',D)then x("`,` Expected")end;local Y=z(H)local P;if q.ConsumeSymbol(',',D)then P=z(H)end;if not
q.ConsumeKeyword('do',D)then x("`do` expected")end
local V=_(M)
if not q.ConsumeKeyword('end',D)then x("`end` expected")end
R={AstType='NumericForStatement',Scope=M,Variable=F,Start=W,End=Y,Step=P,Body=V,Tokens=D}else local M=s(H)local F={M:CreateLocal(C.Data)}
while
q.ConsumeSymbol(',',D)do
if not q.Is('Ident')then x("for variable expected.")end;F[#F+1]=M:CreateLocal(q.Get(D).Data)end
if not q.ConsumeKeyword('in',D)then x("`in` expected.")end;local W={z(H)}while q.ConsumeSymbol(',',D)do W[#W+1]=z(H)end;if not
q.ConsumeKeyword('do',D)then x("`do` expected.")end
local Y=_(M)
if not q.ConsumeKeyword('end',D)then x("`end` expected.")end
R={AstType='GenericForStatement',Scope=M,VariableList=F,Generators=W,Body=Y,Tokens=D}end elseif U=='repeat'then q.Get(D)local C=_(H)if not q.ConsumeKeyword('until',D)then
x("`until` expected.")end;local M=z(C.Scope)
R={AstType='RepeatStatement',Condition=M,Body=C,Tokens=D}elseif U=='function'then q.Get(D)if not q.Is('Ident')then
x("Function name expected")end;local C=A(H,true)local M=O(H,D)M.IsLocal=false
M.Name=C;R=M elseif U=='local'then q.Get(D)
if q.Is('Ident')then local C={q.Get(D).Data}
while
q.ConsumeSymbol(',',D)do
if not q.Is('Ident')then x("local var name expected")end;C[#C+1]=q.Get(D).Data end;local M={}if q.ConsumeSymbol('=',D)then repeat M[#M+1]=z(H)until
not q.ConsumeSymbol(',',D)end;for F,W in pairs(C)do
C[F]=H:CreateLocal(W)end
R={AstType='LocalStatement',LocalList=C,InitList=M,Tokens=D}elseif q.ConsumeKeyword('function',D)then if not q.Is('Ident')then
x("Function name expected")end;local C=q.Get(D).Data
local M=H:CreateLocal(C)local F=O(H,D)F.Name=M;F.IsLocal=true;R=F else
x("local var or function def expected")end elseif U=='::'then q.Get(D)
if not q.Is('Ident')then x('Label name expected')end;local C=q.Get(D).Data;if not q.ConsumeSymbol('::',D)then
x("`::` expected")end
R={AstType='LabelStatement',Label=C,Tokens=D}elseif U=='return'then q.Get(D)local C={}if not q.IsKeyword('end')then
local M,F=pcall(function()return z(H)end)
if M then C[1]=F;while q.ConsumeSymbol(',',D)do C[#C+1]=z(H)end end end
R={AstType='ReturnStatement',Arguments=C,Tokens=D}elseif U=='break'then q.Get(D)R={AstType='BreakStatement',Tokens=D}elseif U=='goto'then
q.Get(D)if not q.Is('Ident')then x("Label expected")end
local C=q.Get(D).Data;R={AstType='GotoStatement',Label=C,Tokens=D}end end
if not R then local U=A(H)
if q.IsSymbol(',')or q.IsSymbol('=')then if
(U.ParenCount or 0)>0 then
x("Can not assign to parenthesized expression, is not an lvalue")end;local C={U}while
q.ConsumeSymbol(',',D)do C[#C+1]=A(H)end;if not q.ConsumeSymbol('=',D)then
x("`=` Expected.")end;local M={z(H)}while q.ConsumeSymbol(',',D)do
M[#M+1]=z(H)end
R={AstType='AssignmentStatement',Lhs=C,Rhs=M,Tokens=D}elseif U.AstType=='CallExpr'or U.AstType=='TableCallExpr'or
U.AstType=='StringCallExpr'then
R={AstType='CallStatement',Expression=U,Tokens=D}else x("Assignment Statement Expected")end end
if q.IsSymbol(';')then R.Semicolon=q.Get(R.Tokens)end;return R end
function _(H)local R={}local D={Scope=s(H),AstType='Statlist',Body=R,Tokens={}}
while not
f[q.Peek().Data]and not q.IsEof()do local L=S(D.Scope)R[#R+1]=L end
if q.IsEof()then local L={}L.AstType='Eof'L.Tokens={q.Get()}R[#R+1]=L end;return D end;return _(s())end;return{LexLua=g,ParseLua=k}end
a["howl.lexer.walk"]=function(...)local function n()end;local function s(l,u)u(l.Base)
for c,m in ipairs(l.Arguments)do u(m)end end
local function h(l,u)u(l.Base)u(l.Index)end;local r
local function d(l,u)local c=r[l.AstType]if not c then
error("No visitor for "..l.AstType)end;c(l,u)end
r={VarExpr=n,NumberExpr=n,StringExpr=n,BooleanExpr=n,NilExpr=n,DotsExpr=n,Eof=n,BinopExpr=function(l,u)u(l.Lhs)u(l.Rhs)end,UnopExpr=function(l,u)u(l.Rhs)end,CallExpr=s,TableCallExpr=s,StringCallExpr=s,IndexExpr=h,MemberExpr=h,Function=function(l,u)if l.Name and not
l.IsLocal then u(l.Name)end;u(l.Body)end,ConstructorExpr=function(l,u)
for c,m in
ipairs(l.EntryList)do if m.Type=="Key"then u(m.Key)end;u(m.Value)end end,Parentheses=function(l,u)u(v.Inner)end,Statlist=function(l,u)for c,m in
ipairs(l.Body)do u(m)end end,ReturnStatement=function(l,u)
for c,m in ipairs(l.Arguments)do u(m)end end,AssignmentStatement=function(l,u)for c,m in ipairs(l.Lhs)do u(m)end;for c,m in
ipairs(l.Rhs)do u(m)end end,LocalStatement=function(l,u)for c,m in
ipairs(l.InitList)do u(m)end end,CallStatement=function(l,u)u(v.Expression)end,IfStatement=function(l,u)
for c,m in
ipairs(l.Clauses)do if m.Condition then u(m.Condition)end;u(m.Body)end end,WhileStatement=function(l,u)u(l.Condition)
u(l.Body)end,DoStatement=function(l,u)u(l.Body)end,BreakStatement=n,LabelStatement=n,GotoStatement=n,RepeatStatement=function(l,u)u(l.Body)
u(l.Condition)end,GenericForStatement=function(l,u)for c,m in ipairs(l.Generators)do u(m)end
u(l.Body)end,NumericForStatement=function(l,u)u(l.Start)u(l.End)if l.Step then
u(l.Step)end;u(l.Body)end}return d end
a["howl.tasks.Context"]=function(...)local n=i"howl.platform"local s=i"howl.class"
local h=i"howl.class.mixin"
local r=s("howl.tasks.Context"):include(h.sealed)
function r:initialize(l)self.ran={}self.filesProduced={}self.tasks=l.tasks
self.default=l.default;self.Traceback=l.Traceback;self.ShowTime=l.ShowTime;self.env=l.env
self:BuildCache()end
function r:DoRequire(l,u)if self.filesProduced[l]then return true end
local c=self.producesCache[l]
if c then self.filesProduced[l]=true;return self:Run(c)end;c=self.normalMapsCache[l]local m,f;local w=l;if c then
self.filesProduced[l]=true;f=c.Name;m=c.Pattern.From end
for y,p in
pairs(self.patternMapsCache)do if l:match(y)then self.filesProduced[l]=true;f=p.Name
m=l:gsub(y,p.Pattern.From)break end end
if f then local y=self:DoRequire(m,true)if not y then
if not u then self.env.logger:error(
"Cannot find '"..m.."'")end;return false end
return self:Run(f,m,w)end;if fs.exists(fs.combine(self.env.root,l))then
self.filesProduced[l]=true;return true end;if not u then
self.env.logger:error(
"Cannot find a task matching '"..l.."'")end;return false end;local function d(l,u)local c=#l;if#l~=#u then return false end
for m=1,c do if l[m]~=u[m]then return false end end;return true end
function r:Run(l,...)
local u=l
if type(l)=="string"then u=self.tasks[l]if not u then
error("Cannot find a task called '"..l.."'")return false end elseif not u or not u.Run then
error(
"Cannot call task "..tostring(u).." as it has no 'Run' method")return false end;local c={...}local m=self.ran[u]
if not m then m={c}self.ran[u]=m else for f=1,#m do if d(c,m[f])then
return false end end;m[#m+1]=c end;n.refreshYield()return u:Run(self,...)end;r.run=r.Run
function r:Start(l)local u
if l then u=self.tasks[l]else u=self.default;l="<default>"end;if not u then
self.env.logger:error("Cannot find a task called '"..l.."'")return false end;return self:Run(u)end
function r:BuildCache()local l={}local u={}local c={}self.producesCache=l;self.patternMapsCache=u
self.normalMapsCache=c
for m,f in pairs(self.tasks)do local w=f.produces;if w then
for p,v in ipairs(w)do local b=l[v]if b then
error(string.format("Both '%s' and '%s' produces '%s'",b,m,v))end;l[v]=m end end
local y=f.maps
if y then
for p,v in ipairs(y)do
local b=(v.Type=="Pattern"and u or c)local g=v.To;local k=b[g]if k then
error(string.format("Both '%s' and '%s' match '%s'",k,m,g))end;b[g]={Name=m,Pattern=v}end end end;return self end;return r end
a["howl.tasks.dependency.FileDependency"]=function(...)local n=i"howl.lib.assert"
local s=i"howl.tasks.Task"local h=i"howl.tasks.dependency.Dependency"
local r=h:subclass("howl.tasks.dependency.FileDependency")function r:initialize(l,u)h.initialize(self,l)
n.argType(u,"string","initialize",1)self.path=u end
function r:setup(l,u)end;function r:resolve(l,u)return u:DoRequire(self.path)end
local d={}return
{apply=function()s:addDependency(r,"requires")end,FileDependency=r}end
a["howl.tasks.dependency.TaskDependency"]=function(...)local n=i"howl.lib.assert"
local s=i"howl.tasks.Task"local h=i"howl.tasks.dependency.Dependency"
local r=h:subclass("howl.tasks.dependency.TaskDependency")function r:initialize(l,u)h.initialize(self,l)
n.argType(u,"string","initialize",1)self.name=u end
function r:setup(l,u)if not
u.tasks[self.name]then
l.logger:error("Task '%s': cannot resolve dependency '%s'",self.task.name,self.name)end end;function r:resolve(l,u)return u:run(self.name)end;local d={}
return{apply=function()
s:addDependency(r,"depends")end,TaskDependency=r}end
a["howl.tasks.dependency.Dependency"]=function(...)local n=i"howl.class"
local s=n("howl.tasks.dependency.Dependency")
function s:initialize(h)if self.class==s then
error("Cannot create instance of abstract class "..tostring(s),2)end;self.task=h end;function s:setup(h,r)
error("setup has not been overridden in "..self.class,2)end;function s:resolve(h,r)
error("resolve has not been overridden in "..self.class,2)end;return s end
a["howl.tasks.extensions"]=function(...)local n=i"howl.tasks.Runner"local s=i"howl.lib.colored"
local h={}
function h:ListTasks(r,d)local l={}local u=0
for c,m in pairs(self.tasks)do local f=c:sub(1,1)
if d or
(f~="_"and f~=".")then local w=m.description or""local y=#c;if y>u then u=y end;l[c]=w end end;u=u+2;r=r or""for c,m in pairs(l)do s.writeColor("white",r..c)
s.printColor("lightGray",string.rep(" ",
u-#c)..m)end;return self end
function h:Clean(r,d,l)
return
self:AddTask(r,l,function(u,c)
c.logger:verbose("Emptying directory '"..d.."'")local m=fs.combine(c.root,d)
if fs.isDir(m)then for f,w in pairs(fs.list(m))do
fs.delete(fs.combine(m,w))end else fs.delete(m)end end):Description(
"Clean the '"..d.."' directory")end;n:include(h)end
a["howl.tasks.Task"]=function(...)local n=i"howl.lib.assert"local s=i"howl.class"
local h=i"howl.lib.colored"local r=i"howl.class.mixin"local d=i"howl.lib.utils"local l=table.insert
local function u(m,f)
local w=d.parsePattern(m,true)local y=d.parsePattern(f)local p=w.Type
n(p==y.Type,"Both from and to must be the same type "..p.." and "..
w.Type)return{Type=p,From=w.Text,To=y.Text}end
local c=s("howl.tasks.Task"):include(r.configurable):include(r.optionGroup)
function c:initialize(m,f,w)n.argType(m,"string","Task",1)if type(f)=="function"then w=f
f={}end;self.options={}self.name=m;self.action=w
self.dependencies={}self.description=nil;self.maps={}self.produces={}if f then
self:depends(f)end end
function c.static:addDependency(s,m)
local function f(w,...)
if

select('#',...)==1 and type(...)=="table"and(# (...)>0 or next(...)==nil)then local y=...for p=1,#y do l(w.dependencies,s(w,y[p]))end else
l(w.dependencies,s(w,...))end;return w end;self[m]=f;self[m:gsub("^%l",string.upper)]=f;return
self end;function c:setup(m,f)end
function c:Produces(m)
if type(m)=="table"then local f=self.produces;for w,m in ipairs(m)do
table.insert(f,m)end else table.insert(self.produces,m)end;return self end
function c:Maps(m,f)table.insert(self.maps,u(m,f))return self end;function c:Action(m)self.action=m;return self end;function c:Description(m)
self.description=m;return self end
function c:RunAction(m,...)if self.action then
return self.action(self,m,...)else return true end end
function c:Run(m,...)local f=false
if#self.dependencies==0 then f=true else for g,k in ipairs(self.dependencies)do if
k:resolve(m.env,m)then f=true end end end;if not f then return false end;for g,k in ipairs(self.produces)do
m.filesProduced[k]=true end;local w={...}local y=""if#w>0 then local g={}for k,q in ipairs(w)do
table.insert(g,tostring(q))end
y=" ("..table.concat(g,", ")..")"end;m.env.logger:info("Running %s",
self.name..y)local p=os.clock()
local v,b=true,nil
if m.Traceback then
xpcall(function()self:RunAction(m.env,unpack(w))end,function(g)
for k=5,15
do local q,b=pcall(function()error("",k)end)if
g:match("Howlfile")then break end;g=g.."\n  "..b end;b=g;v=false end)else v,b=pcall(self.RunAction,self,m.env,...)end;if v then
m.env.logger:success("%s finished",self.name)else m.env.logger:error("%s: %s",self.name,b)
error("Error running tasks",0)end;if m.ShowTime then
print(" ",
"Took "..os.clock()-p.."s")end;return true end;return c end
a["howl.tasks.OptionTask"]=function(...)local n=i"howl.lib.assert"local s=i"howl.class.mixin"
local h=rawset;local r=i"howl.tasks.Task"
local d=r:subclass("howl.tasks.OptionTask"):include(s.configurable)
function d:initialize(l,u,c,m)r.initialize(self,l,u,m)self.options={}
self.optionKeys={}for f,w in ipairs(c or{})do self:addOption(w)end end
function d:addOption(l)local u=self.options
local c=function(m,f)if f==nil then f=true end;u[l]=f;return m end;self[l:gsub("^%l",string.upper)]=c;self[l]=c
self.optionKeys[l]=true end;function d:configure(l)n.argType(l,"table","configure",1)
for u,c in pairs(l)do if
self.optionKeys[u]then self.options[u]=c else end end end;return d end
a["howl.tasks.Runner"]=function(...)local n=i"howl.tasks.Task"local s=i"howl.tasks.Context"
local h=i"howl.lib.colored"local r=i"howl.class"local d=i"howl.class.mixin"
local l=r("howl.tasks.Runner"):include(d.sealed)
function l:initialize(u)self.tasks={}self.default=nil;self.env=u end
function l:setup()
for u,c in pairs(self.tasks)do c:setup(self.env,self)end;if self.env.logger.hasError then return false end;for u,c in
pairs(self.tasks)do
for u,m in ipairs(c.dependencies)do m:setup(self.env,self)end end;if self.env.logger.hasError then return
false end;return true end;function l:Task(u)
return function(c,m)return self:AddTask(u,c,m)end end;function l:AddTask(u,c,m)
return self:InjectTask(n(u,c,m))end;function l:InjectTask(u,c)
self.tasks[c or u.name]=u;return u end
function l:Default(u)local c
if u==nil then self.default=nil elseif type(u)==
"string"then self.default=self.tasks[u]if not self.default then
error("Cannot find task "..u)end else self.default=n("<default>",{},u)end;return self end;function l:Run(u)return self:RunMany({u})end
function l:RunMany(u)
local c=os.clock()local m=true;local f=s(self)if#u==0 then f:Start()else
for w,y in ipairs(u)do m=f:Start(y)end end;if f.ShowTime then
h.printColor("orange","Took "..os.clock()-c..
"s in total")end;return m end;return l end
a["howl.cli"]=function(...)local n=i"howl.loader"local s=i"howl.lib.colored"
local h=i"howl.platform".fs;local r,d=n.FindHowl()
local l=i"howl.context"(d or shell.dir(),{...})
local function u(p)
l.logger:verbose("Including "..p.name..": "..p.description)p.apply()if p.setup then p.setup(l)end end;local c=l.arguments
c:Option"verbose":Alias"v":Description"Print verbose output"
c:Option"time":Alias"t":Description"Display the time taken for tasks"
c:Option"trace":Description"Print a stack trace on errors"
c:Option"help":Alias"?":Alias"h":Description"Print this help"i"howl.tasks.extensions"i"howl.depends.bootstrap"i"howl.depends.combiner"
i"howl.external.busted"i"howl.files.compilr"i"howl.files.require"
u(i"howl.modules.gist")u(i"howl.modules.minify")
u(i"howl.modules.require")u(i"howl.modules.clean")
i"howl.tasks.dependency.TaskDependency".apply()
i"howl.tasks.dependency.FileDependency".apply()local m=c:Arguments()
local function f()if c:Get"help"then m={"help"}end end
l.mediator:subscribe({"ArgParse","changed"},f)f()
if not r then
if#m==1 and m[1]=="help"then
s.writeColor("yellow","Howl")
s.printColor("lightGrey"," is a simple build system for Lua")
s.printColor("grey","You can read the full documentation online: https://github.com/SquidDev-CC/Howl/wiki/")
s.printColor("white",(([[
			The key thing you are missing is a HowlFile. This can be "Howlfile" or "Howlfile.lua".
			Then you need to define some tasks. Maybe something like this:
		]]):gsub("\t",""):gsub("\n+$","")))
s.printColor("magenta",'Tasks:minify("minify", "file.lua", "file.min.lua")')
s.printColor("white","Now just run '"..shell.getRunningProgram().." minify'!")s.printColor("orange","\nOptions:")c:Help("  ")elseif#m==0 then
error(
d..
" Use "..shell.getRunningProgram().." --help to dislay usage.",0)else error(d,0)end;return end
l.logger:verbose("Found HowlFile at "..h.combine(d,r))local w,y=n.SetupTasks(l,r)
w:Task"list"(function()w:ListTasks()end):Description"Lists all the tasks"
w:Task"help"(function()print("Howl [options] [task]")
s.printColor("orange","Tasks:")w:ListTasks("  ")
s.printColor("orange","\nOptions:")c:Help("  ")end):Description"Print out a detailed usage for Howl"
w:Default(function()l.logger:error("No default task exists.")
l.logger:verbose("Use 'Tasks:Default' to define a default task")s.printColor("orange","Choose from: ")
w:ListTasks("  ")end)y.dofile(h.combine(d,r))if not w:setup()then
error("Error setting up tasks",0)end;if not w:RunMany(m)then
error("Error running tasks",0)end end
a["howl.depends.combiner"]=function(...)local n=i"howl.lib.mediator"local s=i"howl.depends"
local h=i"howl.tasks.Runner"local r=i"howl.tasks.OptionTask"i"howl.depends.modules.verify"
i"howl.depends.modules.traceback"local d="_W"
local l=("local function "..d..
[[(f)
	local e=setmetatable({}, {__index = _ENV or getfenv()})
	if setfenv then setfenv(f, e) end
	return f(e) or e
end]]):gsub("[\t\n ]+"," ")
function s.Dependencies:Combiner(u,c,m)
local f=u.mediator:getChannel{"Combiner"}m=m or{}local w=self.path;local y=self.shouldExport
local p=fs.open(fs.combine(u.root,c),"w")assert(p,"Could not create "..c)
local v=f:getChannel("include")local b,g;do local q=p.writeLine;local j=f:getChannel("write")local x=j.publish;g=function(z,_)if
x(j,{},self,_,z,m)then q(z)end end
b={write=g,path=c}end
f:getChannel("start"):publish({},self,b,m)if m.header~=false then g(l)end;local k={}
for q in self:Iterate()do local j=q.path
local x=fs.open(fs.combine(w,j),"r")
assert(x,"File "..j.." does not exist")local z=x.readAll()x.close()local _,E=v:publish({},self,q,z,m)
if not _ then
p.close()error(E[#E]or"Unknown error")end;u.logger:verbose("Adding "..j)local T=q.name
if
q.type=="Main"then g(z,q.alias or q.path)elseif q.type=="Resource"then
local A=assert(T,
"A name must be specified for resource "..q.path).."="
if not q.shouldExport then A="local "..A elseif not y then k[#k+1]=T;A="local "..A end
g(A..string.format("%q",z),q.alias or q.path)elseif T then local A,O=d..'(function(_ENV, ...)','end)'if q.noWrap then
A,O='(function(...)','end)()'end;local I=T..'='..A
if not q.shouldExport then
I="local "..I elseif not y then k[#k+1]=T;I="local "..I end;g(I)g(z,T)g(O)else local A=not q.noWrap;if A then g("do")end
g(z,q.alias or q.path)if A then g('end')end end end
if#k>0 and#self.mainFiles==0 then local q={}for j,x in ipairs(k)do q[#q+1]=x..
"="..x..", "end;g("return {"..
table.concat(q).."}")end
f:getChannel("end"):publish({},self,b,m)p.close()end
function h:Combine(u,c,m,f)
return
self:InjectTask(r(u,f,{"header","finalizer","traceback","lineMapping","verify"},function(w,y)
c:Combiner(y,m,w.options)end)):Description(
"Combines files into '"..m.."'"):Produces(m):Requires(c:Paths())end end
a["howl.depends.modules.traceback"]=function(...)local n=string.find
local s=i"howl.lib.dump".serialize;local h=i"howl.lib.mediator"local r=i"howl.depends"
local d={header=[[
		-- Maps
		local lineToModule = {{lineToModule}}
		local getLine(line)
			while line >= 0 do
				local l = lineToModule[line]
				if l then return l end
				line = line - 1
			end
			return -1
		})
		local moduleStarts = {{moduleStarts}}
		local programEnd = {{lastLine}}

		-- Stores the current file, safer than shell.getRunningProgram()
		local _, currentFile = pcall(error, "", 2)
		currentFile = currentFile:match("[^:]+")
	]],updateError=[[
		-- If we are in the current file then we should map to the old modules
		if filename == currentFile then

			-- If this line is after the program end then
			-- something is broken, and so we just roll with it
			if line > programEnd then return end

			-- convert to module lines
			filename = getLine(line) or "<?>"
			local newLine = moduleStarts[filename]
			if newLine then
				line = line - newLine + 1
			else
				line = -1
			end
		end
	]]}
local l={header=[[
		local finalizer = function(message, traceback) {{finalizer}} end
	]],parseTrace=[[
		local ok, finaliserError = pcall(finalizer, message, traceback)

		if not ok then
			printError("Finalizer Error: ", finaliserError)
		end
	]]}
local u=([[
end
-- The main program executor
	local args = {...}
	local currentTerm = term.current()
	local ok, returns = xpcall(
		function() return {__program(unpack(args))} end,
		function(message)
			local _, err = pcall(function()
			local error, pcall, printError, tostring,setmetatable = error, pcall, printError, tostring, setmetatable
			{{header}}

			local messageMeta = {
				__tostring = function(self)
					local msg = self[1] or "<?>"
					if self[2] then msg = msg .. ":" .. tostring(self[2]) end
					if self[3] and self[3] ~= " " then msg = msg .. ":" .. tostring(self[3]) end
					return msg
				end
			}
			local function updateError(err)
				local filename, line, message = err:match("([^:]+):(%d+):?(.*)")
				-- Something is really broken if we can't find a filename
				-- If we can't find a line number than we must have `pcall:` or `xpcall`
				-- This means, we shouldn't have an error, so we must be debugging somewhere
				if not filename or not line then return end
				line = tonumber(line)
				{{updateError}}
				return setmetatable({filename, line, message}, messageMeta)
			end

			-- Reset terminal
			term.redirect(currentTerm)

			-- Build a traceback
			local topError = updateError(message) or message
			local traceback = {topError}
			for i = 6, 6 + 18 do
				local _, err = pcall(error, "", i)
				err = updateError(err)
				if not err then break end
				traceback[#traceback + 1] = err
			end

			{{parseTrace}}

			printError(tostring(topError))
			if #traceback > 1 then
				printError("Raw Stack Trace:")
				for i = 2, #traceback do
					printError("  ", tostring(traceback[i]))
				end
			end
			end)
			if not _ then printError(err) end
		end
	)

	if ok then
		return unpack(returns)
	end
]])
local function c(w)local y,p,v=1,1,1;local b=1;local g=#w;while y<g do p,v=n(w,'\n',y,true)if not p then break end;b=b+1
y=v+1 end;return b end;local function m(w,y)
return w:gsub("{{(.-)}}",function(p)return y[p]or""end)end
h:subscribe({"Combiner","start"},function(w,y,p)if w.finalizer then
p.traceback=true end;if p.lineMapping then p.oldLine=0;p.line=0;p.lineToModule={}
p.moduleStarts={}end;if p.traceback then
y.write("local __program = function(...)")end end)local f=math.min
h:subscribe({"Combiner","write"},function(w,y,p,v)
if v.lineMapping then y=y or"file"local b=v.line
v.oldLine=b;local g=b+c(p)v.line=g;b=b+1;g=g-1;local k,q=v.moduleStarts,v.lineToModule
local j=k[y]if j then k[y]=f(b,j)else k[y]=b end;q[f(b,g)]=y end end)
h:subscribe({"Combiner","end"},function(w,y,p)
if p.traceback then local v={}local b={}
if w.finalizer then local k=w.finalizer.path
local q=fs.combine(w.path,k)
local j=assert(fs.open(q,"r"),"Finalizer "..q.." does not exist")local x=j.readAll()j.close()if#x==0 then x=nil else
h:publish({"Combiner","include"},w,l,x,p)end
if x then v[#v+1]=l;b.finalizer=x end end
if p.lineMapping then v[#v+1]=d;b.lineToModule=s(p.lineToModule)
b.moduleStarts=s(p.moduleStarts)b.lastLine=p.line end;local g={}for k,q in ipairs(v)do
for j,x in pairs(q)do local z=g[j]if z then z=z.."\n"else z=""end;g[j]=z..x end end
y.write(m(m(u,g),b))end end)
function r.Dependencies:Finalizer(w)
local y=self:FindFile(w)or self:File(w)y.type="Finalizer"self.finalizer=y
h:publish({"Dependencies","create"},self,y)return y end end
a["howl.depends.modules.verify"]=function(...)local n=i"howl.lib.mediator"local s=i"howl.depends"
local h=loadstring
n:subscribe({"Combiner","include"},function(r,d,l,u)
if u.verify and d.verify~=false then local c,m=h(l)
if not c then
local f=d.path
local w="Could not load ".. (f and("file "..f)or"string")if m~="nil"then w=w..":\n"..m end;return false,w end end end)
n:subscribe({"Dependencies","create"},function(r,d)
if d.type=="Resource"then d:Verify(false)end end)
function s.File:Verify(r)if r==nil then r=true end;self.verify=r;return self end end
a["howl.depends"]=function(...)local n=i"howl.lib.mediator"local s=i"howl.class"
local h=i"howl.class.mixin"
local r=s("howl.depends.Files"):include(h.sealed)function r:Name(l)self.name=l;self:Alias(l)return self end;function r:Alias(l)
self.alias=l;return self end
function r:Depends(l)
if type(l)=="table"then for u,c in ipairs(l)do
self:Depends(c)end else table.insert(self.dependencies,l)end;return self end
function r:Prerequisite(l)
if type(l)=="table"then
for u,c in ipairs(l)do self:Prerequisite(c)end else table.insert(self.dependencies,1,l)end;return self end
function r:Export(l)if l==nil then l=true end;self.shouldExport=l;return self end
function r:NoWrap(l)if l==nil then l=true end;self.noWrap=l;return self end
function r:initialize(l,u)self.dependencies={}self.name=nil;self.alias=nil;self.path=l
self.shouldExport=true;self.noWrap=false;self.type="File"self.parent=u end
local d=s("howl.depends.Dependencies"):include(h.sealed)
function d:initialize(l,u)self.mainFiles={}self.files={}self.path=l;self.namespaces={}
self.shouldExport=false;self.parent=u end;function d:File(l)local u=r(l,self)self.files[l]=u
n:publish({"Dependencies","create"},self,u)return u end;function d:Resource(l)
local u=r(l,self)u.type="Resource"self.files[l]=u
n:publish({"Dependencies","create"},self,u)return u end
function d:Main(l)local u=
self:FindFile(l)or r(l,self)u.type="Main"
table.insert(self.mainFiles,u)n:publish({"Dependencies","create"},self,u)
return u end
function d:Depends(l)local u=self.mainFiles[1]
assert(u,"Cannot find a main file")u:Depends(l)return self end
function d:Prerequisite(l)local u=self.mainFiles[1]
assert(u,"Cannot find a main file")u:Prerequisite(l)return self end
function d:FindFile(l)local u=self.files;local c=u[l]if c then return c end;c=u[l..".lua"]
if c then return c end;for m,c in pairs(u)do if c.alias==l then return c end end;return nil end
function d:Iterate()local l={}
local function u(m)if l[m.path]then return end;l[m.path]=true;for f,w in ipairs(m.dependencies)do
local y=self:FindFile(w)
if not y then error("Cannot find file "..w)end;u(y)end
coroutine.yield(m)end;local c=self.mainFiles;if#c==0 then c=self.files end
return coroutine.wrap(function()for m,f in pairs(c)do
u(f)end end)end
function d:Export(l)if l==nil then l=true end;self.shouldExport=l;return self end
function d:Namespace(l,u,c)
local m=Factory(fs.combine(self.path,u or""),self)self.namespaces[l]=m;c(m)return m end
function d:CloneDependencies()local l=setmetatable({},{__index=d})
for u,c in pairs(self)do l[u]=c end;l.mainFiles={}return l end;function d:Paths()local l,u=table.insert,{}
for c,m in pairs(self.files)do l(u,m.path)end;return u end
n:subscribe({"HowlFile","env"},function(l,u)l.Dependencies=function(...)return
d(u.root,...)end
l.Sources=d(u.root)end)return{File=r,Dependencies=d}end
a["howl.depends.bootstrap"]=function(...)local n=i"howl.depends"local s=i"howl.tasks.Runner"
local h=i"howl.tasks.OptionTask"local r=string.format
local d=[[
local args = {...}
xpcall(function()
	(function(...)
]]
local l=[[
	end)(unpack(args))
end, function(err)
	printError(err)
	for i = 3, 15 do
		local s, msg = pcall(error, "", i)
		if msg:match("xpcall") then break end
		printError("  ", msg)
	end
	error(err:match(":.+"):sub(2), 3)
end)
]]
local u=[[
local env = setmetatable({}, {__index = getfenv()})
local function openFile(filePath)
	local f = assert(fs.open(filePath, "r"), "Cannot open " .. filePath)
	local contents = f.readAll()
	f.close()
	return contents
end
local function doWithResult(file)
	local currentEnv = setmetatable({}, {__index = env})
	local result = setfenv(assert(loadfile(file), "Cannot find " .. file), currentEnv)()
	if result ~= nil then return result end
	return currentEnv
end
local function doFile(file, ...)
	return setfenv(assert(loadfile(file), "Cannot find " .. file), env)(...)
end
]]
function n.Dependencies:CreateBootstrap(m,f,w)local y=self.path
local p=fs.open(fs.combine(m.root,f),"w")assert(p,"Could not create"..f)if w.traceback then
p.writeLine(d)end;p.writeLine(u)
for v in self:Iterate()do
local b=r("%q",fs.combine(y,v.path))local g=v.name
if v.type=="Main"then
p.writeLine("doFile("..b..", ...)")elseif v.type=="Resource"then
p.writeLine("env["..r("%q",g)"] = openFile("..b..")")elseif g then
p.writeLine("env["..
r("%q",g).."] = "..
(v.noWrap and"doFile"or"doWithResult").."("..b..")")else p.writeLine("doFile("..b..")")end end;if w.traceback then p.writeLine(l)end;p.close()end;local c={}
function c:CreateBootstrap(m,f,w,y)
return
self:InjectTask(h(m,y,{"traceback"},function(p,v)
f:CreateBootstrap(v,w,p.options)end)):Description(
"Creates a 'dynamic' combination of files in '"..w.."')"):Produces(w):Requires(f:Paths())end;s:include(c)end
a["howl.context"]=function(...)local n=i"howl.lib.assert"local s=i"howl.class"
local h=i"howl.class.mixin"local r=i"howl.lib.mediator"local d=i"howl.lib.argparse"local l=i"howl.lib.Logger"
local u=s("howl.Context"):include(h.sealed)
function u:initialize(c,m)
n.type(c,"string","bad argument #1 for Context expected string, got %s")
n.type(m,"table","bad argument #2 for Context expected table, got %s")self.root=c;self.out="build"self.mediator=r
self.arguments=d.Options(self.mediator,m)self.logger=l(self)end;return u end
a["howl.files.matcher"]=function(...)local n=i"howl.lib.utils"
local s={["^"]="%^",["$"]="%$",["("]="%(",[")"]="%)",["%"]="%%",["."]="%.",["["]="%[",["]"]="%]",["+"]="%+",["-"]="%-",["\0"]="%z"}local h={["*"]="(.*)"}for c,m in pairs(s)do h[c]=m end;local function r(c,m)
return m:match(c.text)end;local function d(c,m)return c.text==m end;local function l(c,m)
return c.func(m)end
local function u(c)local m=type(c)
if m=="string"then local f=n.startsWith(c,"pattern:")or
n.startsWith(c,"ptrn:")if f then return
{tag="pattern",text=f,match=r}end
if c:find("%*")then local c="^"..
c:gsub(".",h).."$"return{tag="pattern",text=c,match=r}end;return{tag="text",text=c,match=d}elseif m=="function"or(m=="table"and
(getmetatable(c)or{}).__call)then return
{tag="function",func=c,match=l}else error("Expected string or function")end end;return{createMatcher=u}end
a["howl.files.require"]=function(...)local n=i"howl.files"local s=i"howl.tasks.Runner"
local h=i"howl.tasks.OptionTask"
local r=[=[
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents()
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
]=]
local d="local env = setmetatable({ require = require }, { __index = getfenv() })\n"
local function l(u)return
u:gsub("%.lua$",""):gsub("/","."):gsub("^(.*)%.init$","%1")end
function n:AsRequire(u,c,m)local f=self.path;m=m or{}local w=m.link;local y=self:Files()if not
y[self.startup]then
error('You must have a file called '..self.startup..' to be executed at runtime.')end;local p={r}if w then
p[#p+1]=d end
for b,g in pairs(y)do
u.logger:verbose("Including "..b)local k=fs.combine(f,b)
p[#p+1]="preload[\""..l(b).."\"] = "
if w then assert(fs.exists(k),"Cannot find "..b)p[#p+1]=
"assert(loadfile(\""..k.."\", env))\n"else
local q=fs.open(k,"r")local j=q.readAll()q.close()
p[#p+1]="function(...)\n"..j.."\nend\n"end end
p[#p+1]="return preload[\""..l(self.startup).."\"](...)"local v=fs.open(fs.combine(u.root,c),"w")
v.write(table.concat(p))v.close()end
function s:AsRequire(u,c,m,f)return
self:InjectTask(h(u,f,{"link"},function(w,y)c:AsRequire(y,m,w.options)end)):Description("Packages files together to allow require"):Produces(m)end end
a["howl.files.CopySource"]=function(...)local n=i"howl.lib.assert"local s=i"howl.files.matcher"
local h=i"howl.class.mixin"local r=i"howl.platform".fs;local d=i"howl.files.Source"local l=table.insert
local u=d:subclass("howl.files.CopySource")
function u:initialize(c,m)d.initialize(self,c,m)self.renames={}self.modifiers={}end
function u:configure(c)n.argType(c,"table","configure",1)
d.configure(self,c)if c.rename~=nil then self:rename(c.rename)end;if
c.modify~=nil then self:modify(c.modify)end end
function u:rename(c,m)local f,w=type(c),type(m)
if f=="table"and m==nil then for y,p in ipairs(c)do
self:rename(p)end elseif f=="function"and m==nil then l(self.renames,c)elseif f==
"string"and w=="string"then l(self.renames,function(y)
return(y.name:gsub(c,m))end)else
error(
"bad arguments for rename (expected table, function or string, string pair, got "..f.." and "..w..")",2)end end
function u:modify(c)local m=type(c)
if m=="table"then
for f,w in ipairs(c)do self:modify(w)end elseif m=="function"then l(self.modifiers,c)else
error("bad argument #1 for modify (expected table or function, got "..m..
")",2)end end
function u:doMutate(c)
for m,f in ipairs(self.modifiers)do local w=f(c)if w then c.contents=w end end
for m,f in ipairs(self.renames)do local w=f(c)if w then c.name=w end end
if self.parent then return self.parent:doMutate(c)else return c end end
function u:buildFile(c,m)return
self:doMutate{path=c,relative=m,name=m,contents=r.read(c)}end;return u end
a["howl.files"]=function(...)local n=i"howl.lib.mediator"local s=i"howl.lib.utils"
local h=i"howl.lib.assert"local r=i"howl.class"local d=i"howl.class.mixin"
local l=r("howl.files.Files"):include(d.sealed)
function l:Add(u)
if type(u)=="table"then for c,m in ipairs(u)do self:Add(m)end else
table.insert(self.include,self:_Parse(u))self.files=nil end;return self end
function l:Remove(u)
if type(u)=="table"then for c,m in ipairs(u)do self:Remove(m)end else
table.insert(self.exclude,self:_Parse(u))self.files=nil end;return self end;l.Include=l.Add;l.Exclude=l.Remove
function l:Startup(u)self.startup=u;return self end
function l:Files()
if not self.files then self.files={}
for u,c in ipairs(self.include)do if c.Type=="Normal"then
self:_Include(c.Text)else self:_Include("",c)end end end;return self.files end
function l:_Include(u,c)if u~=""then
for f,c in pairs(self.exclude)do if c.Match(u)then return end end end
local m=fs.combine(self.path,u)h(fs.exists(m),"Cannot find path "..u)if
fs.isDir(m)then for f,w in ipairs(fs.list(m))do
self:_Include(fs.combine(u,w),c)end elseif not c or c.Match(u)then
self.files[u]=true end end
function l:_Parse(u)u=s.parsePattern(u)local c=u.Text
if u.Type=="Normal"then
function u.Match(m)return c==m end else function u.Match(m)return m:match(c)end end;return u end
function l:initialize(u)
h.type(u,"string","bad argument #1 for Files expected string, got %s")self.path=u;self.include={}self.exclude={}self.startup='startup'
self:Remove{".git",".idea","Howlfile.lua","Howlfile","build"}end
n:subscribe({"HowlFile","env"},function(u,c)
u.Files=function(m)return l(m or c.root)end end)return l end
a["howl.files.Source"]=function(...)local n=i"howl.lib.assert"local s=i"howl.class"
local h=i"howl.files.matcher"local r=i"howl.class.mixin"local d=i"howl.platform".fs;local l=table.insert
local u=s("howl.files.Source"):include(r.configurable):include(r.filterable)
local function c(w)local y=type(w)
if y=="function"or y=="string"then
return h.createMatcher(w)elseif y=="table"and w.tag and w.predicate then return w else return nil end end
local function m(w,y,p,v)local b=c(y)local g=type(y)
if b then l(w,b)elseif g=="table"then
for v,k in ipairs(y)do local b=c(k)if b then l(w,b)else
error("bad item #"..v..

" for "..p.." (expected pattern, got "..type(k)..")")end end else
error("bad argument #"..v..
" for "..p.." (expected pattern, got "..g..")")end end;local function f(w,y)for p,v in pairs(w)do if v:match(y)then return true end end
return false end;function u:initialize(w,y)
if w==nil then w=true end;self.parent=y;self.children={}self.includes={}self.excludes={}
self.allowEmpty=w end
function u:from(w,y)
n.argType(w,"string","from",1)w=d.normalise(w)local p=self.children[w]
if not p then
p=self.class(true)self.children[w]=p;self.allowEmpty=false end;if y~=nil then return p:configureWith(y)else return p end end
function u:include(...)local w=select('#',...)local y={...}for p=1,w do
m(self.includes,y[p],"include",p)end;return self end
function u:exclude(...)local w=select('#',...)local y={...}for p=1,w do
m(self.excludes,y[p],"exclude",p)end;return self end
function u:excluded(w)if f(self.excludes,w)then return true elseif self.parent then
return self.parent:excluded(w)else return false end end
function u:included(w)if#self.includes==0 then return self.allowEmpty else
return f(self.includes,w)end end
function u:configure(w)n.argType(w,"table","configure",1)if w.include~=nil then
self:include(w.include)end
if w.exclude~=nil then self:exclude(w.exclude)end
if w.with~=nil then
n.type(w.with,"table","expected table for with, got %s")for y,p in ipairs(w.with)do self:with(p)end end end;function u:matches(w)
return self:included(w)and not self:excluded(w)end
function u:gatherFiles(w,y,p)if not p then p={}end
for v,b in
pairs(self.children)do local g=d.combine(w,v)b:gatherFiles(g,y,p)end
if self.allowEmpty or#self.includes>0 then local v,b={w},1;local g=#p
while b>0 do
local k=v[b]local q=k:sub(#w+2)b=b-1
if d.isDir(k)then
if not self:excluded(q)then
if y and
self:included(q)then g=g+1;p[g]=self:buildFile(k,q)end
for j,x in ipairs(d.list(k))do b=b+1;v[b]=d.combine(k,x)end end elseif self:included(q)and not self:excluded(q)then g=g+1
p[g]=self:buildFile(k,q)end end end;return p end;function u:buildFile(w,y)return{path=w,relative=y,name=y}end;return u end
a["howl.files.compilr"]=function(...)local n=i"howl.files"local s=i"howl.lib.dump"
local h=i"howl.lexer.rebuild"local r=i"howl.tasks.Runner"
local d=[=[--[[Hideously Smashed Together by Compilr, a Hideous Smash-Stuff-Togetherer, (c) 2014 oeed
	This file REALLLLLLLY isn't suitable to be used for anything other than being executed
	To extract all the files, run: "<filename> --extract" in the Shell
]]
]=]
local l=[[
local function run(tArgs)
	local fnFile, err = loadstring(files[%q], %q)
	if err then error(err) end

	local function split(str, pat)
		 local t = {}
		 local fpat = "(.-)" .. pat
		 local last_end = 1
		 local s, e, cap = str:find(fpat, 1)
		 while s do
				if s ~= 1 or cap ~= "" then
		 table.insert(t,cap)
				end
				last_end = e+1
				s, e, cap = str:find(fpat, last_end)
		 end
		 if last_end <= #str then
				cap = str:sub(last_end)
				table.insert(t, cap)
		 end
		 return t
	end

	local function resolveTreeForPath(path, single)
		local _files = files
		local parts = split(path, '/')
		if parts then
			for i, v in ipairs(parts) do
				if #v > 0 then
					if _files[v] then
						_files = _files[v]
					else
						_files = nil
						break
					end
				end
			end
		elseif #path > 0 and path ~= '/' then
			_files = _files[path]
		end
		if not single or type(_files) == 'string' then
			return _files
		end
	end

	local oldFs = fs
	local env
	env = {
		fs = {
			list = function(path)
							local list = {}
							if fs.exists(path) then
						list = fs.list(path)
							end
				for k, v in pairs(resolveTreeForPath(path)) do
					if not fs.exists(path .. '/' ..k) then
						table.insert(list, k)
					end
				end
				return list
			end,

			exists = function(path)
				if fs.exists(path) then
					return true
				elseif resolveTreeForPath(path) then
					return true
				else
					return false
				end
			end,

			isDir = function(path)
				if fs.isDir(path) then
					return true
				else
					local tree = resolveTreeForPath(path)
					if tree and type(tree) == 'table' then
						return true
					else
						return false
					end
				end
			end,

			isReadOnly = function(path)
				if not fs.isReadOnly(path) then
					return false
				else
					return true
				end
			end,

			getName = fs.getName,
			getSize = fs.getSize,
			getFreespace = fs.getFreespace,
			makeDir = fs.makeDir,
			move = fs.move,
			copy = fs.copy,
			delete = fs.delete,
			combine = fs.combine,

			open = function(path, mode)
				if fs.exists(path) then
					return fs.open(path, mode)
				elseif type(resolveTreeForPath(path)) == 'string' then
					local handle = {close = function()end}
					if mode == 'r' then
						local content = resolveTreeForPath(path)
						handle.readAll = function()
							return content
						end

						local line = 1
						local lines = split(content, '\n')
						handle.readLine = function()
							if line > #lines then
								return nil
							else
								return lines[line]
							end
							line = line + 1
						end
											return handle
					else
						error('Cannot write to read-only file (compilr archived).')
					end
				else
					return fs.open(path, mode)
				end
			end
		},

		loadfile = function( _sFile )
				local file = env.fs.open( _sFile, "r" )
				if file then
						local func, err = loadstring( file.readAll(), fs.getName( _sFile ) )
						file.close()
						return func, err
				end
				return nil, "File not found: ".._sFile
		end,

		dofile = function( _sFile )
				local fnFile, e = env.loadfile( _sFile )
				if fnFile then
						setfenv( fnFile, getfenv(2) )
						return fnFile()
				else
						error( e, 2 )
				end
		end
	}

	setmetatable( env, { __index = _G } )

	local tAPIsLoading = {}
	env.os.loadAPI = function( _sPath )
			local sName = fs.getName( _sPath )
			if tAPIsLoading[sName] == true then
					printError( "API "..sName.." is already being loaded" )
					return false
			end
			tAPIsLoading[sName] = true

			local tEnv = {}
			setmetatable( tEnv, { __index = env } )
			local fnAPI, err = env.loadfile( _sPath )
			if fnAPI then
					setfenv( fnAPI, tEnv )
					fnAPI()
			else
					printError( err )
					tAPIsLoading[sName] = nil
					return false
			end

			local tAPI = {}
			for k,v in pairs( tEnv ) do
					tAPI[k] =  v
			end

			env[sName] = tAPI
			tAPIsLoading[sName] = nil
			return true
	end

	env.shell = shell

	setfenv( fnFile, env )
	fnFile(unpack(tArgs))
end

local function extract()
		local function node(path, tree)
				if type(tree) == 'table' then
						fs.makeDir(path)
						for k, v in pairs(tree) do
								node(path .. '/' .. k, v)
						end
				else
						local f = fs.open(path, 'w')
						if f then
								f.write(tree)
								f.close()
						end
				end
		end
		node('', files)
end

local tArgs = {...}
if #tArgs == 1 and tArgs[1] == '--extract' then
	extract()
else
	run(tArgs)
end
]]
function n:Compilr(u,c,m)local f=self.path;m=m or{}local w=self:Files()if
not w[self.startup]then
error('You must have a file called '..self.startup..' to be executed at runtime.')end;local y={}
for b,g in pairs(w)do
local k=fs.open(fs.combine(f,b),"r")local q=k.readAll()k.close()if m.minify and loadstring(q)then
q=h.MinifyString(q)end;local j=y
local x={b:match((b:gsub("[^/]+/?","([^/]+)/?")))}x[#x]=nil
for g,z in pairs(x)do local _=j[z]if not _ then _={}j[z]=_ end;j=_ end;j[fs.getName(b)]=q end
local p=d.."local files = "..s.serialize(y)..
"\n"..string.format(l,self.startup,self.startup)if m.minify then p=h.MinifyString(p)end
local v=fs.open(fs.combine(u.root,c),"w")v.write(p)v.close()end
function r:Compilr(u,c,m,f)return
self:AddTask(u,f,function(w,y)c:Compilr(y,m)end):Description("Combines multiple files using Compilr"):Produces(m)end end
if shell then return a["howl.cli"](...)else return{require=i,preload=a}end